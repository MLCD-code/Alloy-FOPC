<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-03-31 Sun 09:51 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Short experiment with answer substitution in E</title>
<meta name="author" content="CMSMcQ" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Short experiment with answer substitution in E</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orge040e44">1. E can provide answer substitutions</a></li>
<li><a href="#orga600f98">2. Are answer substitutions what we need?</a></li>
<li><a href="#orga03f28d">3. A concrete case:  if Socrates exists, Socrates is a philosopher</a></li>
<li><a href="#orga68e902">4. Conclusions</a></li>
</ul>
</div>
</div>
<p>
I want to do a little experiment with the theorem prover E.
</p>

<div id="outline-container-orge040e44" class="outline-2">
<h2 id="orge040e44"><span class="section-number-2">1.</span> E can provide answer substitutions</h2>
<div class="outline-text-2" id="text-1">
<p>
The usage notes say it can perform "answer substitutions", which from
the example appears to be more or less what Prolog does when providing
an answer to a user query.
</p>

<blockquote>
<p>
Starting with version 1.3, E is able to provide answer
substitutions. It currently adheres to the Tuple version of the TPTP
proposal for answer extraction. To use this feature, you need to
specify an existentially quantified conjecture formula with the
formula type question, as in the example below. This implies the use
of the TPTP-3/TSTP syntax.
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-tptp">fof(socrates,axiom,(philosopher(socrates))).
fof(plato,axiom,(philosopher(plato))).      
fof(hume,axiom,(philosopher(hume))).
fof(philosphers_exist,question,(?[X]:(philosopher(X)))).
</pre>
</div>

<blockquote>
<p>
By default, E will stop searching after the first answer. The
<code>--answers</code> option can be used to specify for how many answers E will
keep searching : <code>eprover --answers=2 ans_test01.p</code>
</p>
</blockquote>

<p>
Consulting Spivey I see that the term <i>answer substitution</i> is one I
should recognize: it's not more or less but precisely what Prolog
does.
</p>

<p>
As a baseline, what happens if we submit the example given above to
<i>E</i>?  Here is the command:
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org02629c8">/opt/local/bin/eprover --auto --answers=2 --output-level=0 ../examples/phil01.p
</pre>
</div>

<pre class="example" id="org2c34fba">
# No SInE strategy applied
# Auto-Mode selected heuristic G_E___208_C18_F1_SE_CS_SP_PS_S5PRR_RG_S04AN
# and selection function SelectComplexExceptUniqMaxHorn.
#
# Presaturation interreduction done
# SZS status Theorem
# SZS answers Tuple [[hume]|_]
# SZS answers Tuple [[plato]|_]

# Proof found!
</pre>

<p>
`
</p>
</div>
</div>


<div id="outline-container-orga600f98" class="outline-2">
<h2 id="orga600f98"><span class="section-number-2">2.</span> Are answer substitutions what we need?</h2>
<div class="outline-text-2" id="text-2">
<p>
However, our situation appears to be a little different when we wish
to find an instance of a model, or perhaps I should say a possible
world which obeys a set of constraints, or to check that a given
instance is in fact compatible with the model.
</p>

<p>
We don't normally expect that it will follow from the constraints of a
definition of <i>tree</i> that three individuals of class Object exist,
arranged such that the child<sub>parent</sub> relation links two of them to the
third.  Nor will it follow that no such individuals can exist.  (If it
does follow that they cannot exist, then the example we are checking
is clearly incompatible with the axioms.)
</p>

<p>
For simplicity, I'll assume that any example we are interested in
consists of some set of individuals of which certain sentences are
true; on this view, any example can be concisely described as a
predicate in Alloy, and if the example is compatible with the
constraints in the Alloy model, then in some possible world the
sentence (some x, y, &#x2026;, z)(P(x, y, &#x2026;, z)) will hold.
</p>

<p>
Since many theorem provers work by negating the demonstrandum,
conjoining it to some set of premises, and then proving the
inconsistency of the resulting set of sentences, it's clear that
checking a set of sentences for consistency or inconsistency is in
priciple within their power.  My difficulty is finding a simple and
reliable way to formulate a problem for which the theorem prover's
solution will tell me whether the set of sentences it started with is
consistent or not.  The obvious problem is that since first-order
logic is only semi-decidable, what I want is not always feasible.
</p>

<p>
But would it be possible to formulate a problem for which a theorem
prover will terminate in most or all simple cases?
</p>
</div>
</div>

<div id="outline-container-orga03f28d" class="outline-2">
<h2 id="orga03f28d"><span class="section-number-2">3.</span> A concrete case:  if Socrates exists, Socrates is a philosopher</h2>
<div class="outline-text-2" id="text-3">
<p>
Suppose, for example, that our axioms were not that Socrates, Plato,
and Hume exist and are philosophers, but but that if Socrates, Plato,
and Hume exist, then they will be philosophers?
</p>

<div class="org-src-container">
<pre class="src src-tptp">fof(soc, axiom, (![X]: (is_socrates(X) =&gt; philosopher(X)))).
fof(pla, axiom, (![X]: (is_plato(X) =&gt; philosopher(X)))).
fof(hum, axiom, (![X]: (is_hume(X) =&gt; philosopher(X)))).
</pre>
</div>

<p>
Unless I am mistaken, a state of affairs in which some individual <i>x</i>
satisfies the predicates <i>is<sub>socrates</sub>(x)</i> and <i>philosopher(x)</i> is
possible but not necessary.  So we won't be able to prove either that
the following conjecture is true, nor that it's false.
</p>
<div class="org-src-container">
<pre class="src src-tptp">&lt;&lt;philosophers&gt;&gt;
fof(philosophers_exist,question,(?[X]:(philosopher(X)))).
</pre>
</div>

<p>
If we hand this problem to <i>E</i> what do we get?
</p>

<pre class="example">
# No SInE strategy applied
# Auto-Mode selected heuristic G_E___208_C18_F1_SE_CS_SP_PS_S5PRR_RG_S04AN
# and selection function SelectComplexExceptUniqMaxHorn.
#
# Presaturation interreduction done

# No proof found!
# SZS status CounterSatisfiable
</pre>


<p>
For what it's worth, negating the question produces (as we should
expect) the same result.  Here is the negation:
</p>

<div class="org-src-container">
<pre class="src src-tptp">&lt;&lt;philosophers&gt;&gt;
fof(philosophers_exist,question,(~ ?[X]:(philosopher(X)))).
</pre>
</div>

<p>
And here is the result:
</p>

<pre class="example">
# No SInE strategy applied
# Auto-Mode selected heuristic G_E___208_C18_F1_SE_CS_SP_PS_S5PRR_RG_S04AN
# and selection function SelectComplexExceptUniqMaxHorn.
#
# Presaturation interreduction done

# No proof found!
# SZS status CounterSatisfiable
</pre>


<p>
The remark "SZS status CounterSatisfiable" seems promising, at least.
I should look more carefully at the documentation.
</p>

<p>
But before I do that, perhaps we can exploit the idea that any
contradiction licenses arbitrary conclusions?  (Yes, but the tasks
assigned in that case to the prover are guaranteed to terminate only
if the example violates the constraints.  We want some task that will
terminate if it <i>conforms</i> to the constraints.)
</p>

<p>
The manual does not mention a mode of operation that amounts to asking
"is this set of propositions consistent?" &#x2013; or possibly it does so
using words I did not recognize as having that meaning.
</p>

<p>
What happens if I hand it a set of axioms without any conjecture or
question?  That is, what if I add the example (here:  there exists a
philosopher) not as a question but as an axiom?
</p>

<p>
Answer:  we get a very similar result.
</p>

<div class="org-src-container">
<pre class="src src-tptp">&lt;&lt;philosophers&gt;&gt;
fof(philosophers_exist,axiom,(?[X]:(philosopher(X)))).
</pre>
</div>

<p>
The message "No proof found!" appears again &#x2013; a bit confusing since
there was nothing to prove.  And the SZS status is "Satisfiable" and
not "CounterSatisfiable".
</p>

<p>
Perhaps this tells us that when the input contains a list of axioms
with no conjecture or question, <i>E</i> does precisely what I was looking
for (or at least: one of the things I am looking for): it checks the
axioms for satisfiability.
</p>

<p>
If we add an inconsistent axiom to the set, what will <i>E</i> do?
</p>

<div class="org-src-container">
<pre class="src src-sh" id="org28d7d69">(cat ../examples/phil04.p \
   ; echo "fof(contradiction, axiom, (p &amp; ~ p)).") \
   | /opt/local/bin/eprover --auto --output-level=0 \
   ; echo $?
</pre>
</div>

<pre class="example">
# No SInE strategy applied
# Auto-Mode selected heuristic G_E___208_C18_F1_SE_CS_SP_PS_S5PRR_RG_S04AN
# and selection function SelectComplexExceptUniqMaxHorn.
#
# Presaturation interreduction done

# Proof found!
# SZS status Unsatisfiable
0
</pre>


<p>
Further consideration of what it says in the manual suggests also that
<i>E</i> makes a helpful three-way distinction in its results:
</p>
<ul class="org-ul">
<li>"Proof found!" means the input (including any negated conjecture)
was found to be inconsistent / non-satisfiable.</li>
<li>"Proof not found!" means the input (including any negated conjecture)
was found to be satisfiable.</li>
<li>"Failure: &#x2026;" means that the result was indeterminate, because
some resource limit or other was exceeded.</li>
</ul>

<p>
That means that in some cases, at least, we will have the terminating
behavior we hoped for, with an affirmative statement that a particular
example is consistent with the constraints.
</p>

<p>
Why does the documentation not say that more directly and explicitly?
I can think of some possible reasons, not mutually exclusive:
</p>

<ul class="org-ul">
<li>Perhaps checking a set of sentences for consistency is not <i>that</i>
common a requirement.</li>
<li>Perhaps it is so blindingly obvious to most users of <i>E</i> that it
does not occur to anyone that it needs saying at all.</li>
<li>Perhaps the documentation does say this already, in a way that
is clear to other readers even if it did not seem clear to me.</li>
</ul>
</div>
</div>

<div id="outline-container-orga68e902" class="outline-2">
<h2 id="orga68e902"><span class="section-number-2">4.</span> Conclusions</h2>
<div class="outline-text-2" id="text-4">
<p>
It appears (I am still feeling a bit tentative) that:
</p>

<ul class="org-ul">
<li>A set of sentences (e.g. the formulas capturing some set of
constraints) can be checked for consistency by submitting the set to
<i>E</i>, without the need to manufacture and append a conjecture to be
proved or disproved.</li>

<li><p>
That means that a possible state of affairs S can be checked for
consistency with a set of sentences or axioms A by just adding a
description of S as an additional sentence.  If S is consistent with
A, <i>E</i> will report "SZS Status Satisfiable"; if S is not consistent
with A, then <i>E</i> will report "SZS Status Unsatisfiable".
</p>

<p>
Or, possibly, it may run out of resources before reaching a result.
</p></li>

<li>If it is a necessary consequence of the axioms that some
individual(s) exist who collectively satisfy some state of affairs
S, then a conjecture to that effect, formulated as an existential
quantification and labeled a "question" in the input, will lead E to
propose (as an answer substitution) one or more sets of individuals
who instantiate S.</li>

<li><p>
If, on the other hand, S is compatible with A but not entailed by A
&#x2013; that is, if S is contingent, not necessary &#x2013; then the answer
substitution facility in <i>E</i> will not propose possible individuals.
</p>

<p>
Perhaps this can be summarized as: <i>E</i> will propose answer
substitutions which will make the existential statement true in
every model of the theory; it will not propose answer substitutions
that will satisfy the statement in some but not all models.
</p></li>

<li><p>
I think that means that I do not know a way to use <i>E</i> to find
instances of a theory in the style of Alloy.
</p>

<p>
But it does seem that in cases where Alloy fails to find an instance
and reports that the model may be contradictory, <i>E</i> may be able to
prove as a theorem that it is contradictory.
</p></li>
</ul>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 30 March 2024</p>
<p class="author">Author: CMSMcQ</p>
<p class="date">Created: 2024-03-31 Sun 09:51</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
