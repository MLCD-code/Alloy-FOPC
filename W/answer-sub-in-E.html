<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-03-31 Sun 08:29 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Short experiment with answer substitution in E</title>
<meta name="author" content="CMSMcQ" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Short experiment with answer substitution in E</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org9ce817a">1. E can provide answer substitutions</a></li>
<li><a href="#orgadda6b0">2. Are answer substitutions what we need?</a></li>
<li><a href="#orgf349e2b">3. A concrete case:  if Socrates exists, Socrates is a philosopher</a></li>
</ul>
</div>
</div>
<p>
I want to do a little experiment with the theorem prover E.
</p>

<div id="outline-container-org9ce817a" class="outline-2">
<h2 id="org9ce817a"><span class="section-number-2">1.</span> E can provide answer substitutions</h2>
<div class="outline-text-2" id="text-1">
<p>
The usage notes say it can perform "answer substitutions", which from
the example appears to be more or less what Prolog does when providing
an answer to a user query.
</p>

<blockquote>
<p>
Starting with version 1.3, E is able to provide answer
substitutions. It currently adheres to the Tuple version of the TPTP
proposal for answer extraction. To use this feature, you need to
specify an existentially quantified conjecture formula with the
formula type question, as in the example below. This implies the use
of the TPTP-3/TSTP syntax.
</p>
</blockquote>
<div class="org-src-container">
<pre class="src src-tptp">fof(socrates,axiom,(philosopher(socrates))).
fof(plato,axiom,(philosopher(plato))).      
fof(hume,axiom,(philosopher(hume))).
fof(philosphers_exist,question,(?[X]:(philosopher(X)))).
</pre>
</div>

<blockquote>
<p>
By default, E will stop searching after the first answer. The
<code>--answers</code> option can be used to specify for how many answers E will
keep searching : <code>eprover --answers=2 ans_test01.p</code>
</p>
</blockquote>

<p>
Consulting Spivey I see that the term <i>answer substitution</i> is one I
should recognize: it's not more or less but precisely what Prolog
does.
</p>

<p>
As a baseline, what happens if we submit the example given above to
<i>E</i>?  Here is the command:
</p>

<pre class="example" id="orgb41a198">
# No SInE strategy applied
# Auto-Mode selected heuristic G_E___208_C18_F1_SE_CS_SP_PS_S5PRR_RG_S04AN
# and selection function SelectComplexExceptUniqMaxHorn.
#
# Presaturation interreduction done
# SZS status Theorem
# SZS answers Tuple [[hume]|_]
# SZS answers Tuple [[plato]|_]

# Proof found!
</pre>
</div>
</div>


<div id="outline-container-orgadda6b0" class="outline-2">
<h2 id="orgadda6b0"><span class="section-number-2">2.</span> Are answer substitutions what we need?</h2>
<div class="outline-text-2" id="text-2">
<p>
However, our situation appears to be a little different when we wish
to find an instance of a model, or perhaps I should say a possible
world which obeys a set of constraints, or to check that a given
instance is in fact compatible with the model.
</p>

<p>
We don't normally expect that it will follow from the constraints of a
definition of <i>tree</i> that three individuals of class Object exist,
arranged such that the child<sub>parent</sub> relation links two of them to the
third.  Nor will it follow that no such individuals can exist.  (If it
does follow that they cannot exist, then the example we are checking
is clearly incompatible with the axioms.)
</p>

<p>
For simplicity, I'll assume that any example we are interested in
consists of some set of individuals of which certain sentences are
true; on this view, any example can be concisely described as a
predicate in Alloy, and if the example is compatible with the
constraints in the Alloy model, then in some possible world the
sentence (some x, y, &#x2026;, z)(P(x, y, &#x2026;, z)) will hold.
</p>

<p>
Since many theorem provers work by negating the demonstrandum,
conjoining it to some set of premises, and then proving the
inconsistency of the resulting set of sentences, it's clear that
checking a set of sentences for consistency or inconsistency is in
priciple within their power.  My difficulty is finding a simple and
reliable way to formulate a problem for which the theorem prover's
solution will tell me whether the set of sentences it started with is
consistent or not.  The obvious problem is that since first-order
logic is only semi-decidable, what I want is not always feasible.
</p>

<p>
But would it be possible to formulate a problem for which a theorem
prover will terminate in most or all simple cases?
</p>
</div>
</div>

<div id="outline-container-orgf349e2b" class="outline-2">
<h2 id="orgf349e2b"><span class="section-number-2">3.</span> A concrete case:  if Socrates exists, Socrates is a philosopher</h2>
<div class="outline-text-2" id="text-3">
<p>
Suppose, for example, that our axioms were not that Socrates, Plato,
and Hume exist and are philosophers, but but that if Socrates, Plato,
and Hume exist, then they will be philosophers?
</p>

<div class="org-src-container">
<pre class="src src-tptp">fof(soc, axiom, (![X]: (is_socrates(X) =&gt; philosopher(X)))).
fof(pla, axiom, (![X]: (is_plato(X) =&gt; philosopher(X)))).
fof(hum, axiom, (![X]: (is_hume(X) =&gt; philosopher(X)))).
</pre>
</div>

<p>
Unless I am mistaken, a state of affairs in which some individual <i>x</i>
satisfies the predicates <i>is<sub>socrates</sub>(x)</i> and <i>philosopher(x)</i> is
possible but not necessary.  So we won't be able to prove either that
the following conjecture is true, nor that it's false.
</p>
<div class="org-src-container">
<pre class="src src-tptp">&lt;&lt;philosophers&gt;&gt;
fof(philosophers_exist,question,(?[X]:(philosopher(X)))).
</pre>
</div>

<p>
If we hand this problem to <i>E</i> what do we get?
</p>

<div class="org-src-container">
<pre class="src src-sh" id="orgdd709fc">/opt/local/bin/eprover --auto --output-level=0 ../examples/phil02.p
</pre>
</div>

<p>
For reasons I do not understand, org mode is not capturing the output
of eprover for that code scrap (actually, it says no output was
produced). When I run it myself, I get this output:
</p>

<pre class="example" id="orgdda6f0b">
# No SInE strategy applied
# Auto-Mode selected heuristic G_E___208_C18_F1_SE_CS_SP_PS_S5PRR_RG_S04AN
# and selection function SelectComplexExceptUniqMaxHorn.
#
# Presaturation interreduction done

# No proof found!
# SZS status CounterSatisfiable
</pre>

<p>
For what it's worth, negating the question produces (as we should
expect) the same result.  Here is the negation:
</p>

<div class="org-src-container">
<pre class="src src-tptp">&lt;&lt;philosophers&gt;&gt;
fof(philosophers_exist,question,(~ ?[X]:(philosopher(X)))).
</pre>
</div>

<p>
And here is the result:
</p>

<p>
[Or rather, here should be the result, except that for reasons I
don't understand org-mode reports that E has produced no output.]
</p>

<p>
The remark "SZS status CounterSatisfiable" seems promising, at least.
I should look more carefully at the documentation.
</p>

<p>
But before I do that, perhaps we can exploit the idea that any
contradiction licenses arbitrary conclusions?  (Yes, but the tasks
assigned in that case to the prover are guaranteed to terminate only
if the example violates the constraints.  We want some task that will
terminate if it <i>conforms</i> to the constraints.)
</p>

<p>
The manual does not mention a mode of operation that amounts to asking
"is this set of propositions consistent?" &#x2013; or possibly it does so
using words I did not recognize as having that meaning.
</p>

<p>
What happens if I hand it a set of axioms without any conjecture or
question?  That is, what if I add the example (here:  there exists a
philosopher) not as a question but as an axiom?
</p>
<div class="org-src-container">
<pre class="src src-tptp">&lt;&lt;philosophers&gt;&gt;
fof(philosophers_exist,axiom,(?[X]:(philosopher(X)))).
</pre>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 30 March 2024</p>
<p class="author">Author: CMSMcQ</p>
<p class="date">Created: 2024-03-31 Sun 08:29</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
