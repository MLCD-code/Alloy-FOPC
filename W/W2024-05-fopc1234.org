#+title: Five varieties of first-order predicate calculus
#+author: CMSMcQ and CH
#+date: 16 May 2024

This document describes several languages for the expression of
logical formulas, each containing the preceding.  For convenient
reference, the languages are given names chosen to suggest their
relative sizes:

- *XS* (extra-small), the first language, is for sentential logic.
- *S* (small) is for first-order logic without identity.
- *M* (medium) is for first-order logic with functions and identity.
  We believe but have not undertaken to prove that M is equivalent to
  the TPTP language of first-order formulas, FOF.
- *L* (large) adds some convenience features: typed quantification,
  unique existential quantification, and skolem functions.  It is at
  least roughly comparable to the TFF (typed first-order formulas)
  language of TPTP.
- *XL* (extra-large) adds sets and set operations.  /Open question:
  add tuples?/

# The grammars given here are adapted from a grammar developed by the
# authors in 2021 and 2022.

* Design goals and design decisions

One goal of the paper is to provide a more precise description of the
target language(s) for our work translating Alloy models into
first-order logic.

A secondary goal is to provide a convenient syntax for presentation
and discussion of formulas that is as far as possible agnostic on the
particular symbols used for quantification and logical operators.
Textbooks on logic are notoriously divergent in their choices of
symbols, and so are those who publish papers containing logical
formulas.  Software for dealing with formulas is equally various in
its choices.  We see no reason to insist that logical conjunction be
expressed with "&" but not with "/\" or "∧" or even just "and", and so
on.

Because different people seem to have different intuitions about which
logical operators should bind more tightly and which less tightly, we
do not attempt an elaborate set of operator priorities.  We allow (A
and (B and C)) to be writte (A and B and C), and similarly for (A or
(B or C)), but otherwise all nested compound expressions must be
parenthesized.  (This is a change from the grammar we worked on in
2021 and 2022.)

To avoid possible confusion over the scope of quantifiers, the same
rule applies to quantifications: we can write ∃x P(x), or (∃x)P(x),
but if the quantifier's scope includes an operator, parentheses are
needed:  ∃x (P(x) ∧ Q(x)).

We assume that for applications of logic to a domain (what Quine calls
post-foundational systems), it is important for identifiers to be
mnemonic, and (thus) that identifiers will often be longer than one
character.  

* Language XS:  sentential logic

Language XS is for sentential logic.

** Basics: Names, whitespace, comments

The basic symbols of the language are Unicode characters.

*** Names

A name is a sequence of characters beginning with a letter and containing
only letters, numeric digits, hyphens, and underscores.
#+name: Names 
#+begin_src ixml :noweb-ref Names
name = letter, namechar*.
-letter = [L].
-namechar = letter; digit; ["-_"].
-digit = [Nd].
#+end_src

Example names:
#+begin_example
p
q
Prop-2a
φ
#+end_example

*** Whitespace

Whitespace is any member of Unicode class Zs (Separator, space), as
well as a few control characters.  Required space is one or more
whitespace characters or comments; optional space is zero or more.
#+name: Whitespace
#+begin_src ixml :noweb-ref Whitespace
-whitespace = -[Zs; #9; #A; #D].
-RS = (whitespace; comment)+.
-os = (whitespace; comment)*.
{ NL for required line breaks }
-NL = (-[Zs; #9] | comment)*, #A, os.
#+end_src

*** Comments
A comment is a string of characters beginning with "\zwnj/\zwnj*"
(slash + asterisk) and ending with "\zwnj*\zwnj/" (asterisk + slash).
Comments may contain other comments, but not unmatched occurrences of
those delimiter strings.  Experience shows that this can easily be
formulated wrong, so we will start with a step-by-step development.
Within the comment, we can be in any of several states:
- *default*: the default state: nothing special has happened -- in
  particular, we have not seen a star or a slash.  In this state,
  several things can happen:
  + The empty string is acceptable (i.e. this can be the last state
    of the comment data.)
  + A character other than slash or asterisk returns us to this state.
  + A nested comment returns us to this state.
  + A slash that does not start a nested comment takes us to state
    *slash-seen*.
  + An asterisk not followed by a slash takes us to state *star-seen*.  
- *star-seen*:  we have seen an asterisk, and must not see a slash
  next.  (If a slash is next, this is the wrong state.)
  + The empty string is acceptable (i.e. this can be the last state
    of the comment data).
  + An asterisk that is not part of the comment-closing delimiter
    returns us to this state.
  + Any character other than a slash or an asteriak returns us to
    the *default* state.
- *slash-seen*:  we have seen a slash, and must not now see an asterisk.
  (If an asterisk is next, this is the wrong state.)
  + The empty string is not acceptable; this must /not/ be the last
    state of the comment data (since the closing delimiter starts
    with the asterisk, which we must not see).
  + A nested comment returns us to the *default* state.
  + A slash that does not start a comment returns us to this state.
  + Any character other than a slash or star returns us to the
    *default* state.

We can describe this with a pseudo-regular grammar for /comment-data/.
(Why "pseudo-regular"?  like a regular grammar, it has rules whose
right-hand sides have a single symbol followed by a non-terminal
naming the next state, but it is not truly regular because /comment/
is not a terminal symbol; it's just treated as if it were one.)

#+begin_src ixml :tangle no
      comment = "/*", comment-data, "*/".
 comment-data = default-state.
default-state = ()
              | ~["/*"], default-state
              | comment, default-state
              | "/", slash-seen
              | "*", star-seen
              .
    star-seen = ()
              | "*", star-seen
              | ~["/*"], default-state
              .
   slash-seen = comment, default-state
              | "/", slash-seen
              | ~["/*"], default-state
              .
#+end_src

The rules for /star-seen/ and /slash-seen/ can be simplified by
applying Arden's Lemma. (/A = X, A; B./ can be rewritten /A = X*, B./)
#+begin_src ixml :tangle no
default-state = ()
              | ~["/*"], default-state
              | comment, default-state
              | "/", slash-seen
              | "*", star-seen
              .          
   star-seen = "*"*, (~["/*"], default-state)?.
  slash-seen = "/"*, (comment | ~["/*"]), default-state.
#+end_src

Now the references to /star-seen/ and /slash-seen/ can be expanded
in place.  We then replace the right-hand side beginning with "*" 
with two simpler right-hand sides.
#+begin_src ixml :tangle no
default-state = ()
              | ~["/*"], default-state
              | comment, default-state
              | "/", "/"*, (comment | ~["/*"]), default-state
              | "*", "*"*, ~["/*"], default-state
              | "*", "*"*
              .          
#+end_src

Further simplification produces:
#+begin_src ixml :tangle no
default-state = "/"*, (comment | ~["/*"]), default-state
              | "*"+, ~["/*"], default-state
              | "*"*
              .          
#+end_src

We can now apply Arden's Lemma to /default-state/ to
produce a single rule for comment data.
#+begin_src ixml :tangle no
default-state = ("*"+, ~["/*"] | "/"*, (comment | ~["/*"]))*, "*"*.          
#+end_src

With that development providing some confidence in the
rule, we can write the comment rules for real now:
#+name: Comments
#+begin_src ixml :noweb-ref Comments
      comment = -"/*", comment-data, -"*/".
-comment-data = ("*"+, ~["/*"] 
                | "/"*, (comment | ~["/*"]))*, 
                "*"*.
#+end_src

This is complicated enough that it may be worth writing down
some positive and negative test cases.  Positive examples include:
#+begin_src data :tangle ../tests/comments-pos-01.txt
/**/
/* */
/* this is a comment */
/* *this* example/test case contains nested stars and a slash (/) */
/*/* a nested comment*/ and more*/
/*/* a nested comment*/*** and ////* another */*/
/*******/
/*//////* test */  ***/
#+end_src

Negative examples:
(1) An asterisk followed by a slash.
#+begin_src data :tangle ../tests/comments-neg-01.txt
/* A slash (*/*) cannot be emphasized here. */
#+end_src
(2) Comment data ending with a slash.
#+begin_src data :tangle ../tests/comments-neg-02.txt
/*///*/
#+end_src

An ad-hoc test grammar will allow us to run these test cases:
#+begin_src ixml :tangle ../tests/comment-tests.ixml :noweb tangle
tests = (whitespace; comment)*.
<<Comments>>
<<Whitespace>>
#+end_src

These tests can be run manually in a shell:
#+begin_example
for f in comments-*.txt ; \
    do markup-blitz.sh $f comment-tests.ixml ${f%.txt}.xml; \
    done
#+end_example
I have no automatic checking of results:  the positive
examples should produce XML results which look plausible,
and the negative examples should all fail to parse.  A quick
check can be done with
#+begin_example
grep ixml:state comments-*.xml
#+end_example

*** Recapitulation (comments)
We can sum up these low-level rules thus:
#+name: Basics
#+begin_src ixml :noweb-ref Basics :noweb yes

{ Basics:  names, whitespace, comments }
<<Names>>
<<Whitespace>>
<<Comments>>
#+end_src

** Propositional variables and constants

A propositional variable is a name.

In language XS, a propositional constant is a name enclosed in single
quotes.  In practice, we'll use typewriter apostrophes, but to allow
formulas to be copy-pasted from contexts which use proper quotation
marks, typeset quotation marks are also allowed (~‘...’~, ~‹...›~,
~›...‹~), as are (sigh) TeX-style single quotation marks (~`...'~).
We allow single guillemets in either order, because both
inward-pointing pairs and outward-pointing pairs are used.  (We have
seen claims that one is French practice and the other German practice,
but we believe we have seen both forms in German typesetting.)

#+name: XS-Atomics
#+begin_src ixml
{ XS Atomics:  propositional variables and constants }
prop-var = @name.
prop-constant = quoted-name; quoted-string.
-quoted-name = -#27, @name, -#27 
               { #27 is typewriter apostrophe }
             | -#60, @name, -#27 
               { #60 is typewriter grave accent }
             | -#2018, @name, -#2019 
               { hi 6, hi 9 }
             | -#203A, @name, -#2039 
               { single guillemets pointing in }
             | -#2039, @name, -#203A 
               { single guillemets pointing out }
             .
#+end_src

At this point, I am mildly tempted to allow arbitrary one-line strings
enclosed in double quotes, so as to make ~"Socrates is a Greek."~ and
="All Greeks are mortal."= allowable as propositional constants.  And,
after all, why not?
#+name: Quoted-strings
#+begin_src ixml
@quoted-string
      > string = -#22, (~[#22; #A]; (#22, #22))*, -#22
               | -#60, -#60, ~[#22; #60; #A]*, -#27, -#27 
               | -#60, -#60, ~[#22; #60; #A]*, -#22 
               | -#201C, ~[#201C; #201D; #A]*, -#201D
               | -#AB, ~[#AB; #BB; #A]*, -#BB
               | -#BB, ~[#AB; #BB; #A]*, -#AB
               .
#+end_src
For the record:
- #22 is a straight typewriter double quotation mark.
- #60 is a grave accent, often used doubled for
  a left double quotation mark by TeX users.
- #201C and #201D are typeset double quotation marks
  conventional in English-language typesetting
  (high 66, high 99).
- #AB and #BB are left- and right-pointing guillemets.
  We allow them to be paired pointing in or pointing
  out, because both styles may be encountered in
  European typesetting.
  
In the first form of quoted string, a double quotation mark in the
string may be represented by two double quotation marks in a row.  We
have not bothered with similar escape mechanisms in the other forms.

** Formulas

In language XS, a basic formula is a propositional variable, a propositional
constant, or a formula enclosed in parentheses.  We allow both round parentheses
and square brackets, to ease the reading of complex formulas.

#+begin_src ixml :noweb-ref XS-Basic-formulas
{ XS Basic formulas }
-basic-formula = prop-var | prop-constant 
               | -"(", os, -formula, os, -")"
               | -"[", os, -formula, os, -"]".
#+end_src

A /formula/ in general is a basic formula or one of several kinds of
compound formulas.
#+begin_src ixml :noweb-ref XS-Formulas
{ XS Formulas in general }
formula = basic-formula | compound-formula.
-compound-formula = not | and | or | implies | iff.
#+end_src

Each logical operator defines a distinct type of compound formula.
#+begin_src ixml :noweb-ref XS-Compound-formulas
{ Compound formulas }
    not = NOT+, basic-formula.
    and = basic-formula++AND, AND, (basic-formula | not).
     or = basic-formula++OR,  OR,  (basic-formula | not).
implies = basic-formula, IMPLIES, (basic-formula | not).
    iff = basic-formula, IFF, (basic-formula | not).
#+end_src

Note that /not/, /and/, and /or/ all allow multiple repetitions of the
operator without parentheses.  Since /and/ and /or/ are associative,
expressions like /A ∧ (B ∧ C)/ and /(A ∧ B) ∧ C/ always have the same
truth value, so there is no reason to require parentheses to specify
one structure or the other.

For conditionals and biconditionals, however, the left- and
right-associative interpretations of expressions like /A implies B
implies C/ or /A iff B iff C/ are not equivalent.  If there were a
principled, easily remembered rationale for choosing left or right
associativity, it would make sense to chose one or the other.  But we
see no such rationale.  To avoid confusion, we require parentheses
around nested occurrences of /implies/ and /iff/.

For the /not/ operator, there is only one imaginable structure, so the
parentheses in an expression like /¬(¬(¬p))/ are optional.  Similarly,
the scope of a negation symbol is clear if it applies to the
right-most operand of an /n/-ary or binary operator.  So /not/
expressions are allowed in those positions.  As a result, the
parentheses are necessary in =(¬p)∨q= and =¬(p∨q)= -- the
expression =¬p∨q= is ungrammatical -- but no parentheses are needed
in =p∨¬q=.

We might wish to consider adding other operators: /xor/ (or /aut/),
/nor/, /nand/.  But since we do not want those operators in language
M, and we want M to be a proper superset of XS, we leave them out.

** Logical Operators
For each operator, we seek to allow a wide variety of different forms:
symbols used in logic textbooks, symbols and keywords used in systems
like Alloy or TLA+ or Z, symbols, keywords, and character sequences
used in combination programming language / theorem provers like ACL2,
Lean, and Agda.  /Not/ included: operators for C.

For the record, a survey of some sources shows the following:
|------------+--------------+---------------+------------------+-----------+---------------+--------+--------|
| Source     | not          | and           | or               | implies   | iff           | forall | exists |
|------------+--------------+---------------+------------------+-----------+---------------+--------+--------|
| Jeffrey    | —            | &             | ∨                | →         | ↔             | (x)    | (∃x)   |
| unnamed*   | ~, ⁓         | ·             | +                | ⊃         | ≡             | ⋀x, Πx | ⋁x, Σx |
| Quine 1941 | ⁓, p̄         | ·             | ∨                | ⊃         | ≡             | (x)    | (∃x)   |
| Smullyan   | ⁓            | ∧             | ∨                | ⊃         | ↔             | ∀x     | ∃x     |
| Quine 1950 | —, p̄         |               | ∨                | →         | ↔             | ∀x     | ∃x     |
| Alloy      | not          | and           | or \zwnj         | implies   | iff           | all x  | some x |
|            | !            | &&            | \vert\vert \zwnj | \zwnj{}=> | <=>           | all x  | some x |
| TLA+       | ¬            | ∧             | ∨                | ⇒         | ≡             | ∀x     | ∃x     |
| TLA+ ASCII | ~            | /\            | \/               | ﻿=>        | <=>           |        |        |
|            | \lnot        | \\zwnj{}land  | \\zwnj{}lor      |           | \\zwnj{}equiv |        |        |
|            | \\zwnj{}neg  |               |                  |           |               |        |        |
| Agda ASCII | \\zwnj{}lnot | \\zwnj{}and   | \\zwnj{}or       |           |               |        |        |
|            | \\zwnj{}neg  | \\zwnj{}wedge | \\zwnj{}vee      |           |               |        |        |
|------------+--------------+---------------+------------------+-----------+---------------+--------+--------|

,* Notes:
- The row labeled 'unnamed' is from Jeffrey's appendix on notation.
- Quine 1941 is /Element logic/, revised edition.
- Smullyan is /First-order logic/.
- Quine 1950 is /Methods of logic/. Conjunction is expressed by
  juxtaposition (and identifiers for propositions are in consequence
  restricted to single characters).
- Alloy also allows double bar (~||~) for disjunction.  It defines
  the additional quantifiers *no*, *lone*, and *one*.
- Agda presumably does have an implication symbol (and equivalence,
  and so on), but I have not progressed far enough to know what it is.

Quine notes that swung dash (⁓) sometimes is used with the
meaning 'iff'.

#+begin_src ixml :noweb-ref Logical-operators
{ Logical operators }
@NOT > op = NOT-sym, os
          | NOT-alpha, RS
          .
NOT-alpha = "not" | "NOT".
  NOT-sym = "¬" { #AC not sign }
          | "-"
          | "—" { #2014 em dash }
          | "~" { #7E tilde }
          | "⁓" { #2053 swung dash }
          . 

@AND > op = os, AND-sym, os
          | RS, AND-alpha, RS
          .
AND-alpha = "and" | "AND"
          | "\land" | "\and" 
          | "\wedge"
          .
  AND-sym = "∧" { #2227 }
          | "&"
          | "&&"
          | "/\" { emacs here wants a " }
          .

 @OR > op = os, OR-sym, os
          | RS, OR-alpha, RS
          .
 OR-alpha = "or" | "OR" 
          | "vel" | "VEL" 
          | "\lor" | "\or" | "\vee"
          .
   OR-sym = "∨" { #2228 logical or }
          | "|" 
          | "||"
          | "\/"
          . 
@IMPLIES > op = os, IMPLIES-sym, os
              | RS, IMPLIES-alpha, RS. 
IMPLIES-alpha = "implies" | "IMPLIES" 
              | "only", os, "if" 
              | "ONLY", os, "IF"
              .
  IMPLIES-sym = "⇒" { #21D2 right double arrow } 
              | "⊃" { #2283 superset of }
              | "→" { #2192 right arrow }
              | "->"
              | "=>"
              .

@IFF > op = os, IFF-sym, os
          | RS, IFF-alpha, RS.
IFF-alpha = "iff" | "IFF"; "\equiv".
  IFF-sym = "⇔" { #21D4 left right double arrow }
          | "↔" { #2194 left right arrow }
          | "≡" { #2261 identical to }
          | "<->"
          | "<=>"
          .
#+end_src
** Recapitulation
The entire XS grammar can now be summarized:
#+begin_src ixml :tangle xs.ixml :noweb tangle
ixml version "1.1".

{ xs.ixml:  grammar for sentential logic }
xs-formulas = os, formula++NL, os.
<<XS-Formulas>>
<<XS-Compound-formulas>>
<<XS-Basic-formulas>>

<<XS-Atomics>>
<<Quoted-strings>>

<<Logical-operators>>

<<Basics>>
#+end_src

** Tests
Some simple positive tests for language XS follow.
First, some propositional variables.
#+begin_src data :noweb-ref XS-Tests-vars
/* Some basic formulas */
/* Propositional variables */
p
q
Prop-2a
φ
א
/* and */
#+end_src
Note that the string "and" is a propositional
variable as well as a logical operator for
conjunction. Parsed as a formula, however, it
can only be the latter.  In the context "A and B"
or "p and q", it can only be the former.
(In the test context, it can be either, however,
so I commented it back out.)

Then, some propositional constants.
#+begin_src data :noweb-ref XS-Tests-constants
/* Propositional constants */
'Prop-2a'
›Frege-was-born-in-1848‹
‹Russell-died-in-1970›
`Prop-2b'

/* Double-quoted strings as propositional constants */
"Frege was born in 1848"
``he is at his desk''
“he is eating lunch”
#+end_src

Then, some propositional constants.
#+begin_src data :noweb-ref XS-Tests-parens-basic
/* Parenthesized basic formulas */
(q)
( Prop-2a )
[(φ)]
['Prop-2a' ]
#+end_src

And now, finally, some compound formulas:
#+begin_src data :noweb-ref XS-Tests-compounds
/* Compound formulas */
(p iff (q&r)) only if (p && q)
(p implies (q & r)) iff (p ∧ q)
(p ∨ q) implies r
p ∨ (q implies r)
p implies (q or r)
"Jones is here" and "Smith is away"
[([(p∨q) ∧ (p∨-q)] ∨ [(-p)∧q]) ⇔ q] ⇒ [(p∧r) ∨ (p∧~r)]
#+end_src

Bringing all the positive examples together,
we have:
#+begin_src data :tangle ../tests/xs-pos-01.txt :noweb tangle
<<XS-Tests-vars>>
<<XS-Tests-constants>>
<<XS-Tests-parens-basic>>
<<XS-Tests-compounds>>
#+end_src
Some negative examples should be added.  But for
now, this may suffice.

* Language S:  first-order logic

Language S adds the following constructs to language XS:
- universal and existential quantification
- constants and variables denoting individuals rather than propositions

** Note on different uses of identifiers 
At thyis point, several classes of names must be distinguished:
- variables ranging over propositions
- constants denoting specific propositions
- variables ranging over individuals
- constants denoting specific individuals
- predicate names (always constants)
- functors (always constants; not present in language S,
  but added in M)

|--------------+---------------+---------------|
|              | Propositions  | Individuals   |
|--------------+---------------+---------------|
| no arguments | Propositional | (Individual)  |
|              | variables     | variables     |
|              | and constants | and constants |
|--------------+---------------+---------------|
| /n/-ary      | Predicate     | Functors      |
|              | names         |               |
|--------------+---------------+---------------|

In some usages, syntactic distinctions are made for these classes of
names (lower- vs upper-case, regions of the alphabet, Latin vs Greek
letters), but in those usages identifiers are typically also limited
to single characters and empirically the identifiers seldom have much
mnemonic value.  Here, the distinctions are made as follows:
- Expressions denoting individuals and those denoting propositions are
  distinguished by context: an entire formula expresses a proposition,
  while an argument to a predicate or functor denotes an individual.
- For expressions with arguments, the functor or predicate name is
  always taken to be a constant: allowing variables would make it a
  higher-order logic.
- In expressions without arguments, the distinction between variables
  and constants is made as above in XS: variables are unmarked,
  constants marked.

/(TBD:  eliminate propositional variables and constants?)/

** Variables and constants
The definitions of /prop-var/ and /prop-constant/ from XS
can be re-used without change.

In addition, we will need variables and constants for
individuals; they will have the same syntax.
#+begin_src ixml :noweb-ref S-Atomics
{ S-Atomics:  terms for individuals }
var = @name.
constant = quoted-name; numeral.
@numeral > name = digit+.
#+end_src

** Predicates
In language S, propositions can take the form of a predicate
symbol followed by a parenthesized list of arguments separated
by commas (and whitespace).  Arguments are variables or constants
denoting individuals.
#+begin_src ixml :noweb-ref Predicates
{ Predicates }
predicate = @name, -"(", os, arg**comma, os, -")".
-arg = var; constant.
-comma = os, -",", os.
#+end_src

Note:
- No whitespace is allowed between the predicate name and the opening
  parenthesis for the list of arguments.
- The argument list must be surrounded by round parentheses; square
  brackets or other forms of brackets are not accepted.

** Quantification
If /F/ is a formula, then /F/ preceded by a universal or existential
quantifier is a formula.  This is a universal or existential
quantification symbol (/FORALL/ or /THERE-EXIST/) followed by one or
more variables, the entire quantifier enclosed in (round) parentheses.
For universal quantification over a single variable, the operator can
be omitted (so "~(x)~" is allowed as an alternate for "~(all x)~").
Whitespace is optional after symbols, required after operators spelled
out with letters.
#+begin_src ixml :noweb-ref Quantification
{ Quantified formulas }
all = universal-quantifier, bracketed-formula.
exist = existential-quantifier, bracketed-formula.

-universal-quantifier = 
        -"(", os, FORALL-sym, os, vars, os, -")"
      | -"(", os, FORALL-lex, RS, vars, os, -")"
      | -"(", os, one-var, os, -")"
      .
-existential-quantifier = 
        -"(", os, EXIST-sym, os, vars, os, -")"
      | -"(", os, EXIST-lex, RS, vars, os, -")"
      .
@vars = var ++ comma-space.
@one-var > vars = var.
-comma-space = os, -",", os, +" ".
#+end_src

As for the logical operators, we allow fairly wide variation in
the spelling of the quantification symbols.
#+begin_src ixml :noweb-ref Quantifier-ops
{ Operators for quantifiers }
@FORALL-lex > op = "all" | "ALL"
      | "for", os, "all" | "FOR", os, "ALL"
      | "A"
      .
@FORALL-sym > op = "∀" { #2200 for all }
      .
@EXIST-lex > op = "exists" | "EXISTS"
      | "exist" | "EXIST"
      | "some" | "SOME"
      | "E"
      .
@EXIST-sym > op = "∃" { #2203 there exists }
      .
#+end_src
  
** Formulas
In language S, the set of basic formulas grows to include
predicates.  Since quantified formulas require bracketing,
they are defined as bracketed formulas.
#+begin_src ixml :noweb-ref S-Basic-formulas
{ S: Basic formulas }
-basic-formula = 
        prop-var 
      | prop-constant 
      | predicate
      | bracketed-formula
      .
-bracketed-formula =  
        -"(", os, -formula, os, -")"
      | -"[", os, -formula, os, -"]"
      | all 
      | exist
      .
#+end_src

The set of all formulas grows to include quantified formulas.
(/Actually, this is now the same as XS, since quantification
was introduced elsewhere./)
#+begin_src ixml :noweb-ref S-Formulas
{ S: Formulas in general }
formula = basic-formula | compound-formula.
-compound-formula = 
        not 
      | and | or 
      | implies | iff
      .
#+end_src

** Recapitulation of language S
The grammar of language S can be summarized:
#+begin_src ixml :tangle s.ixml :noweb tangle
ixml version "1.1".

{ s.ixml:  grammar for first-order logic
  (without identity or functions) }
s-formulas = os, formula++NL, os.
<<S-Formulas>>
<<XS-Compound-formulas>>
<<Quantification>>
<<S-Basic-formulas>>

<<Predicates>>
<<XS-Atomics>>
<<S-Atomics>>
<<Quoted-strings>>

<<Logical-operators>>
<<Quantifier-ops>>

<<Basics>>
#+end_src

** Tests for language S
All tests for language XS can also serve as tests for language S.
So the tests below focus on the new parts of XS.

Let's show some simple predicates.
#+begin_src data :noweb-ref XS-Tests-predicates
/* Predicates */
P(x)
Q(x, y, z)
born('Frege', 1848)
born('Frege', ‹anno-1848›)
born(`Frege', ١٨٤٨)
p()
Φ(x) /\ Δ(υ, ζ)
#+end_src

No whitespace before the parenthesis:
#+begin_src data :tangle ../tests/s-neg-01.txt
P (x)
#+end_src

Double-quoted constants denote propositions, not individuals.  So
~logician("Frege")~ is not grammatical.
#+begin_src data :tangle ../tests/s-neg-02.txt
logician("Frege")
#+end_src

Single quoting is not required (and not allowed) for numerals:
#+begin_src data :tangle ../tests/s-neg-03.txt
born('Frege', ‹1848›)
#+end_src

Quantification is, of course, the main thing:
#+begin_src data :noweb-ref XS-Tests-quantification
(all p)(philosopher(p) implies (some d)(born(p, d)))
(∀ p)(philosopher(p) ⇒ (∃ d)(born(p, d)))
(forall n)(natural(n) implies (exists m)(next(n, m)))
(A n)(natural(n) implies (E m)(next(n, m)))
(~(ALL x)[P(x)]) → (EXISTS x)(~P(x))
#+end_src

Summing it up:
#+begin_src data :tangle ../tests/s-pos-01.txt :noweb tangle
<<XS-Tests-predicates>>

<<XS-Tests-quantification>>
#+end_src

* Language M:  first-order logic with identity and functions

Vis-a-vis language S, language M adds:
- identity and the symbol "~=~"
- functions

Since the function syntax always uses parentheses, and functors are
always constants, language M extends the mechanisms for referring to
an individual: a specific individual can be referred to either by
using a constant like "~'f'~" or "~‹f›~" or by using a zero-argument
function expression like "~f()~".

[Full definition to be supplied.]

* Language L:  additional convenience features

Language L adds a number of convenience features to language M:
- typed quantifications (for all /x/ of type /T/, ...; there is
  some /x/ of type /T/ such that ...)
- unique existential quantification (there exists exactly one
  individual such that ...)
- Skolem expressions (the unique individual who ...)
- negated existential quantification (there is no /x/ such that ...)
- /lone/ existential quantification (there is at most one /x/ such
  that ...)

These are all intended as idioms for concise expression of commonly
used patterns; for each new construct, we specify a standard
translation into language M.

[Full definition to be supplied.]

* Language XL: first-order logic plus set theory

Language XS adds sets /(and tuples? tbd)/ to the universe of
discourse.  Concretely it adds:
- the ability to declare variables as denoting sets of a given type
- syntax for tuples
- the ability to declare variables as denoting tuples in a given
  relation (with symbols allowing the user to distinguish total
  from partial functions, injections, and bijections) 
- symbols for standard set operations (membership, complementation,
  union, intersection, subset relation, set difference)
- set comprehensions

/(The inclusion of tuples, set comprehensions, and various forms of
functions and relations is uncertain.  Our initial instinct was to
exclude them for simplicity and reliability, since the ground has
proved so treacherous for so many.  But it may be that once sets are
added, we have tuples and relations whether we want them or not.  And
in that case, we might as well have set comprehensions to make them
easier to talk about.)/

[Full definition to be supplied.]

* Concluding notes
The grammars defined here have two intended functions:
- They provide specific targets for programs we write
  which are to translate some notation or other into
  'conventional first-order logic'.  That is, they allow
  that vague description to be replaced by a statement
  that the program's output is or should be sentences
  in one of the languages defined here.
- They make it easy to translate formulas into XML form
  so they can be processed by XSLT or XQuery programs.  
  We may write pretty-printers, normalizers, and (of course)
  translations into specific target notations like ACL2
  or TPTP FOF or TFF.
  
** To do
Watch this space.

- Create minimal test case exhibiting /vars/ problem, report.
  
** Questions to consider
At the time this paper was last revised (May 2024 or later), several
questions seemed to merit further consideration.  They are not
strictly speaking open questions, in so far as the grammars given here
provide specific answers to them.  But they are questions in whose
answers the authors do not currently feel completely confident.  Those
we remembered to write down are:

- Q. Should subscripts be allowed in identifiers?

  A. They already are.  The only effective way to allow subscripts is
  to provide some convenient typographic shorthand for them; the
  obvious choice is to separate the base name from the subscript with
  an underscore: thus /x/ with a subscribt of 1 can be written
  ~x\zwnj{}_1~, which can in HTML or on paper be formatted as /x_1/.
  But this is already allowed.

  Perhaps underscore should be allowed in identifiers /only/ with the
  meaning 'subscript'?  And thus only when followed by decimal digits?

  Tentative answer:  unnecessary.

- Q. Include an explicit notation for tuples in language XL?

- Q. Include explicit notation(s) for sequences in language XL?

- Q. Define variant grammars with less variation in the spelling of
  operators?

  Tentative answer: unnecessary.  Consistency of spelling is important
  for presentation, but not for ingestion of formulas.  A normalizer
  can easily be written to reserialize formula sequences in any
  desired form with consistent spelling (and optionally
  pretty-printing).

- Add /xor/ (aka /aut/), /nand/, /nor/?
  
- Eliminate propositional terms in S through XL / allow them only in
  XS?

- Allow marking variables with "~$~"?

- Allow other forms of numbers as individual constants? (Currently
  only unsigned integers are allowed.  And it's only the sentence
  about Frege being born in 1848 that motivates that.)

** Done
Temporary list of to-do items now completed.
- Split all operators into symbolic and alphabetic forms.
  Adjacent space is optional for symbolic form, required
  for alphabetics.  I think this works already for quantifiers,
  but the current grammar allows ~born('Frege', 1848)~ to be
  parsed either as intended or as equivalent to
  ~b ∨ n('Frege', 1848)~, which is going too far.
