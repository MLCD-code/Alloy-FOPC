#+title: Four varieties of first-order predicate calculus
#+author: CMSMcQ and CH
#+date: 16-28 May 2024

This document describes several languages for the expression of
logical formulas, each containing the preceding.  For convenient
reference, the languages are given names chosen to suggest their
relative sizes:

- *XS* (extra-small), the first language, is for sentential logic.
- *S* (small) is for first-order logic without identity.
- *M* (medium) is for first-order logic with functions and identity.
  We believe but have not undertaken to prove that M is equivalent to
  the TPTP language of first-order formulas, FOF.
- *L* (large) adds some convenience features: typed quantification,
  unique existential quantification, and skolem functions.  It is at
  least roughly comparable to the TFF (typed first-order formulas)
  language of TPTP.

There are also some design notes for a possible fifth language:

- *XL* (extra-large) adds sets and set operations.  /Open question:
  add tuples?/

# The grammars given here are adapted from a grammar developed by the
# authors in 2021 and 2022.

* Design goals and design decisions

One goal of the paper is to provide a more precise description of the
target language(s) for our work translating Alloy models into
first-order logic.

A secondary goal is to provide a convenient syntax for presentation
and discussion of formulas that is as far as possible agnostic on the
particular symbols used for quantification and logical operators.
Textbooks on logic are notoriously divergent in their choices of
symbols, and so are those who publish papers containing logical
formulas.  Software for dealing with formulas is equally various in
its choices.  We see no reason to insist that logical conjunction be
expressed with "&" but not with "/\" or "∧" or even just "and", and so
on.

Because different people seem to have different intuitions about which
logical operators should bind more tightly and which less tightly, we
do not attempt an elaborate set of operator priorities.  We allow (A
and (B and C)) to be writte (A and B and C), and similarly for (A or
(B or C)), and we allow unparenthesized negations as operands of
binary operators, but otherwise all nested compound expressions must
be parenthesized.  (This is a change from the grammar we worked on in
2021 and 2022.)

To avoid possible confusion over the scope of quantifiers, any
quantifier must be parenthesized and must be followed by a bracketed
expression explicitly delimiting the scope.  This has the disadvantage
that expressions like "∃x P(x)" are not possible but must be written
more clumsily as "(∃x)(P(x))".  It has on the other hand the advantage
that there can be no confusion over whether the /x/ in "Q(x)" is bound
or free, in "∃x P(x) ∧ Q(x)".  That sequence of characters is not a
formula and it need not be assigned any structural interpretation.
The two formulas nearest to the form given are "(∃x)(P(x)) ∧ Q(x)" and
"(∃x)(P(x) ∧ Q(x))" -- or, using square brackets around the formula
governed by the quantifier, "(∃x)[P(x)] ∧ Q(x)" and "(∃x)[P(x) ∧
Q(x)]".

We assume that for applications of logic to a domain (what Quine calls
post-foundational systems), it is important for identifiers to be
mnemonic, and (thus) that identifiers will often be longer than one
character.  

* Language XS:  sentential logic

Language XS is for sentential logic.

** Basics: Names, whitespace, comments

The basic symbols of the language are Unicode characters.

*** Names

A name is a sequence of characters beginning with a letter and containing
only letters, numeric digits, hyphens, and underscores.
#+name: Names 
#+begin_src ixml :noweb-ref Names
name = letter, namechar*.
-letter = [L].
-namechar = letter; digit; ["-_"].
-digit = [Nd].
#+end_src

Example names:
#+begin_example
p
q
Prop-2a
φ
#+end_example

*** Whitespace

Whitespace is any member of Unicode class Zs (Separator, space), as
well as a few control characters.  Required space is one or more
whitespace characters or comments; optional space is zero or more.
#+name: Whitespace
#+begin_src ixml :noweb-ref Whitespace
-whitespace = -[Zs; #9; #A; #D].
-RS = (whitespace; comment)+.
-os = (whitespace; comment)*.
{ NL for required line breaks }
-NL = (-[Zs; #9] | comment)*, #A, os.
#+end_src

*** Comments
A comment is a string of characters beginning with "\zwnj/\zwnj*"
(slash + asterisk) and ending with "\zwnj*\zwnj/" (asterisk + slash).
Comments may contain other comments, but not unmatched occurrences of
those delimiter strings.  Experience shows that this can easily be
formulated wrong, so we will start with a step-by-step development.
Within the comment, we can be in any of several states:
- *default*: the default state: nothing special has happened -- in
  particular, we have not seen a star or a slash.  In this state,
  several things can happen:
  + The empty string is acceptable (i.e. this can be the last state
    of the comment data.)
  + A character other than slash or asterisk returns us to this state.
  + A nested comment returns us to this state.
  + A slash that does not start a nested comment takes us to state
    *slash-seen*.
  + An asterisk not followed by a slash takes us to state *star-seen*.  
- *star-seen*:  we have seen an asterisk, and must not see a slash
  next.  (If a slash is next, this is the wrong state.)
  + The empty string is acceptable (i.e. this can be the last state
    of the comment data).
  + An asterisk that is not part of the comment-closing delimiter
    returns us to this state.
  + Any character other than a slash or an asteriak returns us to
    the *default* state.
- *slash-seen*:  we have seen a slash, and must not now see an asterisk.
  (If an asterisk is next, this is the wrong state.)
  + The empty string is not acceptable; this must /not/ be the last
    state of the comment data (since the closing delimiter starts
    with the asterisk, which we must not see).
  + A nested comment returns us to the *default* state.
  + A slash that does not start a comment returns us to this state.
  + Any character other than a slash or star returns us to the
    *default* state.

We can describe this with a pseudo-regular grammar for /comment-data/.
(Why "pseudo-regular"?  like a regular grammar, it has rules whose
right-hand sides have a single symbol followed by a non-terminal
naming the next state, but it is not truly regular because /comment/
is not a terminal symbol; it's just treated as if it were one.)

#+begin_src ixml :tangle no
      comment = "/*", comment-data, "*/".
 comment-data = default-state.
default-state = ()
              | ~["/*"], default-state
              | comment, default-state
              | "/", slash-seen
              | "*", star-seen
              .
    star-seen = ()
              | "*", star-seen
              | ~["/*"], default-state
              .
   slash-seen = comment, default-state
              | "/", slash-seen
              | ~["/*"], default-state
              .
#+end_src

The rules for /star-seen/ and /slash-seen/ can be simplified by
applying Arden's Lemma. (/A = X, A; B./ can be rewritten /A = X*, B./)
#+begin_src ixml :tangle no
default-state = ()
              | ~["/*"], default-state
              | comment, default-state
              | "/", slash-seen
              | "*", star-seen
              .          
   star-seen = "*"*, (~["/*"], default-state)?.
  slash-seen = "/"*, (comment | ~["/*"]), default-state.
#+end_src

Now the references to /star-seen/ and /slash-seen/ can be expanded
in place.  We then replace the right-hand side beginning with "*" 
with two simpler right-hand sides.
#+begin_src ixml :tangle no
default-state = ()
              | ~["/*"], default-state
              | comment, default-state
              | "/", "/"*, (comment | ~["/*"]), default-state
              | "*", "*"*, ~["/*"], default-state
              | "*", "*"*
              .          
#+end_src

Further simplification produces:
#+begin_src ixml :tangle no
default-state = "/"*, (comment | ~["/*"]), default-state
              | "*"+, ~["/*"], default-state
              | "*"*
              .          
#+end_src

We can now apply Arden's Lemma to /default-state/ to
produce a single rule for comment data.
#+begin_src ixml :tangle no
default-state = ("*"+, ~["/*"] | "/"*, (comment | ~["/*"]))*, "*"*.          
#+end_src

With that development providing some confidence in the
rule, we can write the comment rules for real now:
#+name: Comments
#+begin_src ixml :noweb-ref Comments
      comment = -"/*", comment-data, -"*/".
-comment-data = ("*"+, ~["/*"] 
                | "/"*, (comment | ~["/*"]))*, 
                "*"*.
#+end_src

This is complicated enough that it may be worth writing down
some positive and negative test cases.  Positive examples include:
#+begin_src data :tangle ../tests/comments-pos-01.txt
/**/
/* */
/* this is a comment */
/* *this* example/test case contains nested stars and a slash (/) */
/*/* a nested comment*/ and more*/
/*/* a nested comment*/*** and ////* another */*/
/*******/
/*//////* test */  ***/
#+end_src

Negative examples:
(1) An asterisk followed by a slash.
#+begin_src data :tangle ../tests/comments-neg-01.txt
/* A slash (*/*) cannot be emphasized here. */
#+end_src
(2) Comment data ending with a slash.
#+begin_src data :tangle ../tests/comments-neg-02.txt
/*///*/
#+end_src

An ad-hoc test grammar will allow us to run these test cases:
#+begin_src ixml :tangle ../tests/comment-tests.ixml :noweb tangle
tests = (whitespace; comment)*.
<<Comments>>
<<Whitespace>>
#+end_src

These tests can be run manually in a shell:
#+begin_example
for f in comments-*.txt ; \
    do markup-blitz.sh $f comment-tests.ixml ${f%.txt}.xml; \
    done
#+end_example
I have no automatic checking of results:  the positive
examples should produce XML results which look plausible,
and the negative examples should all fail to parse.  A quick
check can be done with
#+begin_example
grep ixml:state comments-*.xml
#+end_example

*** Recapitulation (comments)
We can sum up these low-level rules thus:
#+name: Basics
#+begin_src ixml :noweb-ref Basics :noweb yes

{ Basics:  names, whitespace, comments }
<<Names>>
<<Whitespace>>
<<Comments>>
#+end_src

** Propositional variables and constants

A propositional variable is a name.

In language XS, a propositional constant is a name enclosed in single
quotes.  In practice, we'll use typewriter apostrophes, but to allow
formulas to be copy-pasted from contexts which use proper quotation
marks, typeset quotation marks are also allowed (~‘...’~, ~‹...›~,
~›...‹~), as are (sigh) TeX-style single quotation marks (~`...'~).
We allow single guillemets in either order, because both
inward-pointing pairs and outward-pointing pairs are used.  (We have
seen claims that one is French practice and the other German practice,
but we believe we have seen both forms in German typesetting.)

#+name: XS-Atomics
#+begin_src ixml
{ XS Atomics:  propositional variables and constants }
prop-var = @name.
prop-constant = quoted-name; quoted-string.
-quoted-name = -#27, @name, -#27 
               { #27 is typewriter apostrophe }
             | -#60, @name, -#27 
               { #60 is typewriter grave accent }
             | -#2018, @name, -#2019 
               { hi 6, hi 9 }
             | -#203A, @name, -#2039 
               { single guillemets pointing in }
             | -#2039, @name, -#203A 
               { single guillemets pointing out }
             .
#+end_src

At this point, I am mildly tempted to allow arbitrary one-line strings
enclosed in double quotes, so as to make ~"Socrates is a Greek."~ and
="All Greeks are mortal."= allowable as propositional constants.  And,
after all, why not?
#+name: Quoted-strings
#+begin_src ixml
@quoted-string
      > string = -#22, (~[#22; #A]; (#22, #22))*, -#22
               | -#60, -#60, ~[#22; #60; #A]*, -#27, -#27 
               | -#60, -#60, ~[#22; #60; #A]*, -#22 
               | -#201C, ~[#201C; #201D; #A]*, -#201D
               | -#AB, ~[#AB; #BB; #A]*, -#BB
               | -#BB, ~[#AB; #BB; #A]*, -#AB
               .
#+end_src
For the record:
- #22 is a straight typewriter double quotation mark.
- #60 is a grave accent, often used doubled for
  a left double quotation mark by TeX users.
- #201C and #201D are typeset double quotation marks
  conventional in English-language typesetting
  (high 66, high 99).
- #AB and #BB are left- and right-pointing guillemets.
  We allow them to be paired pointing in or pointing
  out, because both styles may be encountered in
  European typesetting.
  
In the first form of quoted string, a double quotation mark in the
string may be represented by two double quotation marks in a row.  We
have not bothered with similar escape mechanisms in the other forms.

** Formulas

In language XS, a basic formula is a propositional variable, a propositional
constant, or a formula enclosed in parentheses.  We allow both round parentheses
and square brackets, to ease the reading of complex formulas.

#+begin_src ixml :noweb-ref XS-Basic-formulas
{ XS Basic formulas }
-basic-formula = prop-var | prop-constant | not
               | -"(", os, -formula, os, -")"
               | -"[", os, -formula, os, -"]".
#+end_src

A /formula/ in general is a basic formula or one of several kinds of
compound formulas.
#+begin_src ixml :noweb-ref XS-Formulas
{ XS Formulas in general }
formula = basic-formula | compound-formula.
-compound-formula = and | or | implies | iff.
#+end_src

Each logical operator defines a distinct type of compound formula.
#+begin_src ixml :noweb-ref XS-Compound-formulas
{ Compound formulas }
    not = NOT, basic-formula.
    and = (and | basic-formula), AND, basic-formula.
     or = (or  | basic-formula),  OR, basic-formula.
implies = basic-formula, IMPLIES, basic-formula.
    iff = basic-formula, IFF, basic-formula.
#+end_src

We want /not/, /and/, and /or/ all to allow multiple repetitions of
the operator without parentheses.  Since /and/ and /or/ are
associative, expressions like /A ∧ (B ∧ C)/ and /(A ∧ B) ∧ C/ always
have the same truth value, so there is no reason to require
parentheses to specify one structure or the other.

For conditionals and biconditionals, however, the left- and
right-associative interpretations of expressions like /A implies B
implies C/ or /A iff B iff C/ are not equivalent.  If there were a
principled, easily remembered rationale for choosing left or right
associativity, it would make sense to chose one or the other.  But we
see no such rationale.  To avoid confusion, we require parentheses
around nested occurrences of /implies/ and /iff/.

For the /not/ operator, there is only one imaginable structure, so the
parentheses in an expression like /¬(¬(¬p))/ are optional.  Similarly,
the scope of a negation symbol is clear if it applies to the
right-most operand of an /n/-ary or binary operator.  So /not/
expressions are allowed in those positions.  As a result, the
parentheses are necessary in =(¬p)∨q= and =¬(p∨q)= -- the expression
=¬p∨q= is ungrammatical -- but no parentheses are needed in =p∨¬q=.

We might wish to consider adding other operators: /xor/ (or /aut/),
/nor/, /nand/.  But since we do not want those operators in language
M, and we want M to be a proper superset of XS, we leave them out.

One minor technical point may be worth making: in general the grammar
tries to retain information about how the input spells the operators,
in case a downstream process wants to preserve those spellings in its
output.  But since we record the operators in an attribute (/@op/),
only one operator spelling can be recorded; this is why we use a
(left-)recursive structure for conjunction and disjunction, instead of
using the natural ixml formulation for /n/-ary operators, which would
be:
#+begin_src ixml
    not = NOT+, basic-formula.
    and = basic-formula++(-AND), AND, basic-formula.
     or = basic-formula++(-OR),  OR,  basic-formula.
#+end_src

** Logical Operators
For each operator, we seek to allow a wide variety of different forms:
symbols used in logic textbooks, symbols and keywords used in systems
like Alloy or TLA+ or Z, symbols, keywords, and character sequences
used in combination programming language / theorem provers like ACL2,
Lean, and Agda.  /Not/ included: operators for C.

For the record, a survey of some sources shows the following:
|------------+--------------+---------------+------------------+-----------+---------------+--------+--------|
| Source     | not          | and           | or               | implies   | iff           | forall | exists |
|------------+--------------+---------------+------------------+-----------+---------------+--------+--------|
| Jeffrey    | —            | &             | ∨                | →         | ↔             | (x)    | (∃x)   |
| unnamed*   | ~, ⁓         | ·             | +                | ⊃         | ≡             | ⋀x, Πx | ⋁x, Σx |
| Quine 1941 | ⁓, p̄         | ·             | ∨                | ⊃         | ≡             | (x)    | (∃x)   |
| Smullyan   | ⁓            | ∧             | ∨                | ⊃         | ↔             | ∀x     | ∃x     |
| Quine 1950 | —, p̄         |               | ∨                | →         | ↔             | ∀x     | ∃x     |
| Alloy      | not          | and           | or \zwnj         | implies   | iff           | all x  | some x |
|            | !            | &&            | \vert\vert \zwnj | \zwnj{}=> | <=>           | all x  | some x |
| TLA+       | ¬            | ∧             | ∨                | ⇒         | ≡             | ∀x     | ∃x     |
| TLA+ ASCII | ~            | /\            | \/               | ﻿=>        | <=>           |        |        |
|            | \lnot        | \\zwnj{}land  | \\zwnj{}lor      |           | \\zwnj{}equiv |        |        |
|            | \\zwnj{}neg  |               |                  |           |               |        |        |
| Agda ASCII | \\zwnj{}lnot | \\zwnj{}and   | \\zwnj{}or       |           |               |        |        |
|            | \\zwnj{}neg  | \\zwnj{}wedge | \\zwnj{}vee      |           |               |        |        |
|------------+--------------+---------------+------------------+-----------+---------------+--------+--------|

,* Notes:
- The row labeled 'unnamed' is from Jeffrey's appendix on notation.
- Quine 1941 is /Elements of logic/, revised edition.
- Smullyan is /First-order logic/.
- Quine 1950 is /Methods of logic/. Conjunction is expressed by
  juxtaposition (and identifiers for propositions are in consequence
  restricted to single characters).
- Alloy also allows double bar (~||~) for disjunction.  It defines
  the additional quantifiers *no*, *lone*, and *one*.
- Agda presumably does have an implication symbol (and equivalence,
  and so on), but I have not progressed far enough to know what it is.

Quine notes that swung dash (⁓) sometimes is used with the
meaning 'iff'.

#+begin_src ixml :noweb-ref Logical-operators
{ Logical operators }
@NOT > op = NOT-sym, os
          | NOT-alpha, RS
          .
NOT-alpha = "not" | "NOT".
  NOT-sym = "¬" { #AC not sign }
          | "-"
          | "—" { #2014 em dash }
          | "~" { #7E tilde }
          | "⁓" { #2053 swung dash }
          . 

@AND > op = os, AND-sym, os
          | RS, AND-alpha, RS
          .
AND-alpha = "and" | "AND"
          | "\land" | "\and" 
          | "\wedge"
          .
  AND-sym = "∧" { #2227 }
          | "&"
          | "&&"
          | "/\" { emacs here wants a " }
          .

 @OR > op = os, OR-sym, os
          | RS, OR-alpha, RS
          .
 OR-alpha = "or" | "OR" 
          | "vel" | "VEL" 
          | "\lor" | "\or" | "\vee"
          .
   OR-sym = "∨" { #2228 logical or }
          | "|" 
          | "||"
          | "\/"
          . 
@IMPLIES > op = os, IMPLIES-sym, os
              | RS, IMPLIES-alpha, RS. 
IMPLIES-alpha = "implies" | "IMPLIES" 
              | "only", os, "if" 
              | "ONLY", os, "IF"
              .
  IMPLIES-sym = "⇒" { #21D2 right double arrow } 
              | "⊃" { #2283 superset of }
              | "→" { #2192 right arrow }
              | "->"
              | "=>"
              .

@IFF > op = os, IFF-sym, os
          | RS, IFF-alpha, RS.
IFF-alpha = "iff" | "IFF"; "\equiv".
  IFF-sym = "⇔" { #21D4 left right double arrow }
          | "↔" { #2194 left right arrow }
          | "≡" { #2261 identical to }
          | "<->"
          | "<=>"
          .
#+end_src
** Recapitulation
The entire XS grammar can now be summarized:
#+begin_src ixml :tangle xs.ixml :noweb tangle
ixml version "1.1".

{ xs.ixml:  grammar for sentential logic }
xs-formulas = os, formula++NL, os.
<<XS-Formulas>>
<<XS-Compound-formulas>>
<<XS-Basic-formulas>>

<<XS-Atomics>>
<<Quoted-strings>>

<<Logical-operators>>

<<Basics>>
#+end_src

** Tests
Some simple positive tests for language XS follow.
First, some propositional variables.
#+begin_src data :noweb-ref XS-Tests-vars
/* Some basic formulas */
/* Propositional variables */
p
q
Prop-2a
φ
א
/* and */
#+end_src
Note that the string "and" is a propositional
variable as well as a logical operator for
conjunction. Parsed as a formula, however, it
can only be the latter.  In the context "A and B"
or "p and q", it can only be the former.
(In the test context, it can be either, however,
so I commented it back out.)

Then, some propositional constants.
#+begin_src data :noweb-ref XS-Tests-constants
/* Propositional constants */
'Prop-2a'
›Frege-was-born-in-1848‹
‹Russell-died-in-1970›
`Prop-2b'

/* Double-quoted strings as propositional constants */
"Frege was born in 1848"
``he is at his desk''
“he is eating lunch”
#+end_src

Then, some propositional constants.
#+begin_src data :noweb-ref XS-Tests-parens-basic
/* Parenthesized basic formulas */
(q)
( Prop-2a )
[(φ)]
['Prop-2a' ]
#+end_src

And now, finally, some compound formulas:
#+begin_src data :noweb-ref XS-Tests-compounds
/* Compound formulas */
(p iff (q&r)) only if (p && q)
(p implies (q & r)) iff (p ∧ q)
(p ∨ q) implies r
p ∨ (q implies r)
p implies (q or r)
"Jones is here" and "Smith is away"
[([(p∨q) ∧ (p∨-q)] ∨ [(-p)∧q]) ⇔ q] ⇒ [(p∧r) ∨ (p∧~r)]
#+end_src

Bringing all the positive examples together,
we have:
#+begin_src data :tangle ../tests/xs-pos-01.txt :noweb tangle
<<XS-Tests-vars>>
<<XS-Tests-constants>>
<<XS-Tests-parens-basic>>
<<XS-Tests-compounds>>
#+end_src
Some negative examples should be added.  But for
now, this may suffice.

* Language S:  first-order logic

Language S adds the following constructs to language XS:
- universal and existential quantification
- constants and variables denoting individuals rather than propositions

** Note on different uses of identifiers 
At thyis point, several classes of names must be distinguished:
- variables ranging over propositions
- constants denoting specific propositions
- variables ranging over individuals
- constants denoting specific individuals
- predicate names (always constants)
- functors (always constants; not present in language S,
  but added in M)

|--------------+---------------+---------------|
|              | Propositions  | Individuals   |
|--------------+---------------+---------------|
| no arguments | Propositional | (Individual)  |
|              | variables     | variables     |
|              | and constants | and constants |
|--------------+---------------+---------------|
| /n/-ary      | Predicate     | Functors      |
|              | names         |               |
|--------------+---------------+---------------|

In some usages, syntactic distinctions are made for these classes of
names (lower- vs upper-case, regions of the alphabet, Latin vs Greek
letters), but in those usages identifiers are typically also limited
to single characters and empirically the identifiers seldom have much
mnemonic value.  Here, the distinctions are made as follows:
- Expressions denoting individuals and those denoting propositions are
  distinguished by context: an entire formula expresses a proposition,
  while an argument to a predicate or functor denotes an individual.
- For expressions with arguments, the functor or predicate name is
  always taken to be a constant: allowing variables would make it a
  higher-order logic.
- In expressions without arguments, the distinction between variables
  and constants is made as above in XS: variables are unmarked,
  constants marked.

/(TBD:  eliminate propositional variables and constants?)/

** Variables and constants
The definitions of /prop-var/ and /prop-constant/ from XS
can be re-used without change.

In addition, we will need variables and constants for
individuals; they will have the same syntax.
#+begin_src ixml :noweb-ref S-Atomics
{ S-Atomics:  terms for individuals }
var = @name.
constant = quoted-name; numeral.
@numeral > name = digit+.
#+end_src
In language S, we define a /term/ as a variable or
a constant.
#+begin_src ixml :noweb-ref S-Terms
{ S-Terms:  terms for individuals }
-term = var; constant.
#+end_src

** Predicates
In language S, propositions can take the form of a predicate
symbol followed by a parenthesized list of arguments separated
by commas (and whitespace).  Arguments are variables or constants
denoting individuals.
#+begin_src ixml :noweb-ref Predicates
{ Predicates }
predicate = @name, -"(", os, arg**comma, os, -")".
-arg = term.
-comma = os, -",", os.
#+end_src

Note:
- No whitespace is allowed between the predicate name and the opening
  parenthesis for the list of arguments.
- The argument list must be surrounded by round parentheses; square
  brackets or other forms of brackets are not accepted.
- The argument list may be empty.
- Predicates with no arguments may be thus be written either with an
  empty argument list (i.e. in the form "~p()~") or with no argument
  list at all ("~p~").  The grammar currently renders these
  differently: the form "~p~" is parsed as a propositional variable
  (/prop-var/); the form "~p()~" is parsed as a /predicate/ named "p"
  with no arguments.
 
** Quantification
If /F/ is a formula, then /F/ preceded by a universal or existential
quantifier is a formula.  This is a universal or existential
quantification symbol (/FORALL/ or /THERE-EXIST/) followed by one or
more variables, the entire quantifier enclosed in (round) parentheses.
For universal quantification over a single variable, the operator can
be omitted (so "~(x)~" is allowed as an alternate for "~(all x)~").
Whitespace is optional after symbols, required after operators spelled
out with letters.
#+begin_src ixml :noweb-ref Quantification
{ Quantified formulas }
-quantified-formula = all | exist.
all = universal-quantifier, os, bracketed-formula.
exist = existential-quantifier, os, bracketed-formula.

-universal-quantifier = 
        -"(", os, FORALL-sym, os, vars, os, -")"
      | -"(", os, FORALL-lex, RS, vars, os, -")"
      | -"(", os, one-var, os, -")"
      .
-existential-quantifier = 
        -"(", os, EXIST-sym, os, vars, os, -")"
      | -"(", os, EXIST-lex, RS, vars, os, -")"
      .
@vars = var ++ comma-space.
@one-var > vars = var.
-comma-space = os, -",", os, +" ".
#+end_src

As for the logical operators, we allow fairly wide variation in
the spelling of the quantification symbols.
#+begin_src ixml :noweb-ref Quantifier-ops
{ Operators for quantifiers }
@FORALL-lex > op = "all" | "ALL"
      | "for", os, "all" | "FOR", os, "ALL"
      | "A"
      .
@FORALL-sym > op = "∀" { #2200 for all }
      .
@EXIST-lex > op = "exists" | "EXISTS"
      | "exist" | "EXIST"
      | "some" | "SOME"
      | "E"
      .
@EXIST-sym > op = "∃" { #2203 there exists }
      .
#+end_src
  
** Formulas
In language S, the set of basic formulas grows to include predicates.
And we give a separate name to bracketed formulas.
#+begin_src ixml :noweb-ref S-Basic-formulas
{ S: Basic formulas }
-basic-formula = 
        prop-var 
      | prop-constant 
      | predicate
      | not
      | bracketed-formula
      .
#+end_src
Since quantified formulas require bracketing, they are defined as
bracketed formulas.
#+begin_src ixml :noweb-ref Bracketed-formulas
-bracketed-formula =  
        -"(", os, -formula, os, -")"
      | -"[", os, -formula, os, -"]"
      | quantified-formula
      .
#+end_src

The set of all formulas grows to include quantified formulas.
(/Actually, this is now the same as XS, since quantification
was introduced elsewhere./)
#+begin_src ixml :noweb-ref S-Formulas
{ S: Formulas in general }
formula = basic-formula | compound-formula.
-compound-formula = and | or | implies | iff.
#+end_src

** Recapitulation of language S
The grammar of language S can be summarized:
#+begin_src ixml :tangle s.ixml :noweb tangle
ixml version "1.1".

{ s.ixml:  grammar for first-order logic
  (without identity or functions) }
s-formulas = os, formula++NL, os.
<<S-Formulas>>
<<XS-Compound-formulas>>
<<Quantification>>
<<S-Basic-formulas>>
<<Bracketed-formulas>>

<<Predicates>>
<<XS-Atomics>>
<<S-Terms>>
<<S-Atomics>>
<<Quoted-strings>>

<<Logical-operators>>
<<Quantifier-ops>>

<<Basics>>
#+end_src

** Tests for language S
All tests for language XS can also serve as tests for language S.
So the tests below focus on the new parts of XS.

Let's show some simple predicates.
#+begin_src data :noweb-ref XS-Tests-predicates
/* Predicates */
P(x)
Q(x, y, z)
born('Frege', 1848)
born('Frege', ‹anno-1848›)
born(`Frege', ١٨٤٨)
p()
Φ(x) /\ Δ(υ, ζ)
#+end_src

No whitespace before the parenthesis:
#+begin_src data :tangle ../tests/s-neg-01.txt
P (x)
#+end_src

Double-quoted constants denote propositions, not individuals.  So
~logician("Frege")~ is not grammatical.
#+begin_src data :tangle ../tests/s-neg-02.txt
logician("Frege")
#+end_src

Single quoting is not required (and not allowed) for numerals:
#+begin_src data :tangle ../tests/s-neg-03.txt
born('Frege', ‹1848›)
#+end_src

Quantification is, of course, the main thing:
#+begin_src data :noweb-ref XS-Tests-quantification
(all p)(philosopher(p) implies (some d)(born(p, d)))
(∀ p)(philosopher(p) ⇒ (∃ d)(born(p, d)))
(forall n)(natural(n) implies (exists m)(next(n, m)))
(A n)(natural(n) implies (E m)(next(n, m)))
(~(ALL x)[P(x)]) → (EXISTS x)(~P(x))
#+end_src

And we need to test at least some quantifications
with multiple variables.
#+begin_src data :noweb-ref XS-Tests-multiple-quantification
/* Some examples from Smullyan */
(ψ ⇒ (∀x)(φ(x))) ≡ (∀y)[ψ ⇒ (φ(y))]
(psi implies (x)(phi(x))) iff (all y)[psi only if (phi(y))]
/* R symmetric: */
(A x)(A y)[R(x,y) implies R(y,x)] 
(FORALL x, y)[R(x,y) implies R(y,x)] 
/* R transitive: */
(x)(y)(z)[(R(x,y) & R(y,z)) implies R(x,z)] 
(all x, y, z)[(R(x,y) & R(y,z)) implies R(x,z)] 
/* R reflexive */
(∀ x, y)(R(x, y) ⇒ R(x, x))

/* Some examples from Quine */
(all y)(some x)((F(y,y) and F(y, x)) or F(x, y))

(all w)(all x)(-[F(x,y) & F(x,w) & F(w,x)])
(ALL w, x)(-[F(x,y) & F(x,w) & F(w,x)])
(E x)(A w)[(-F(x,y)) & ([~F(x,w)] vel not F(w,x) )]
#+end_src
Note that for the last formula, my initial formulation
was "~(E x)(A w)[-F(x,y) & (~F(x,w) vel not F(w,x) )]~",
which suggests I find it natural to assume a tighter
binding for negation than for conjunction.  The same
thing happened on at least one earlier test case; it
suggests we should contemplate making negation bind
more tightly than the binary operators.

Summing it up:
#+begin_src data :tangle ../tests/s-pos-01.txt :noweb tangle
<<XS-Tests-predicates>>

<<XS-Tests-quantification>>
<<XS-Tests-multiple-quantification>>
#+end_src

* Language M:  first-order logic with identity and functions

Vis-a-vis language S, language M adds:
- identity and the symbol "~=~"
- functions, or more precisely function-call expressions or structures,
  e.g. ~f(x)~, denoting individuals

These often go together, but not always.  Quine's /Methods of Logic/
and Smullyan's /First-order logic/ both include identity but have (as
far as I can tell after some searching) no notation for functions.
Prolog, on the other hand, has structures (which can be regarded,
semantically, as calls to functions) but no built-in way to say that
two constants 'a' and 'b' denote the same individual.  (Unification
can do wonders for variables A and B, but atoms like 'a' and 'b'
cannot be unified.)  Perhaps the only reason we think of them as
belonging together is that identity appears to be essential to
describing uniqueness and thus to saying that any function expression
denotes just one individual.

** Identities
We add identities as a form of basic proposition.
#+begin_src ixml :noweb-ref Identities
{ Identities }
identity = term, os, -"=", os, term.
#+end_src

This requires a fresh definition of basic propositions:
#+begin_src ixml :noweb-ref M-Basic-formulas
{ M: Basic formulas }
-basic-formula = 
        prop-var 
      | prop-constant 
      | predicate
      | identity
      | not
      | bracketed-formula
      .
#+end_src

** Functions
The syntax of structures representing references to functions is
identical to that of predicates: a name followed by a list of
comma-separated arguments surrounded by parentheses.  They are
distinguished only by position: predicates appear where formulas
expressing propositions are expected, structures appear where
expressions denoting individuals are expected.
#+begin_src ixml :noweb-ref Structures
{ Structures / function references }
structure = functor, -"(", os, arg**comma, os, -")".
@functor = @name.
#+end_src

Structures give us a new kind of term, so we need to
extend the definition from that of language S:
#+begin_src ixml :noweb-ref M-Terms
{ M-Terms:  terms for individuals }
-term = var; constant; structure.
#+end_src

Note that unless special steps are taken to create rules for types,
all functions are required to be defined for every possible argument:
they must be total over the universe of discourse.  (We can of course
define an object named ›GARBAGE‹ and specify it as the value of the
function for every inconvenient argument.  That is not guaranteed to
produce beautiful results.)

Note also that since the function syntax always uses parentheses, and
functors are always constants, language M extends the mechanisms for
referring to an individual: a specific individual can be referred to
either by using a constant like "~'f'~" or "~‹f›~" or by using a
zero-argument function expression like "~f()~".

** Recapitulation of language M
The grammar of language M can be summarized:
#+begin_src ixml :tangle m.ixml :noweb tangle
ixml version "1.1".

{ m.ixml:  grammar for first-order logic
  with identity and functions }
m-formulas = os, formula++NL, os.
<<S-Formulas>>
<<XS-Compound-formulas>>
<<Quantification>>
<<M-Basic-formulas>>
<<Identities>>
<<Bracketed-formulas>>

<<Predicates>>
<<XS-Atomics>>
<<M-Terms>>
<<S-Atomics>>
<<Structures>>
<<Quoted-strings>>

<<Logical-operators>>
<<Quantifier-ops>>

<<Basics>>
#+end_src

** Tests for language M
Let us formulate a few examples as test cases for the grammar.
#+begin_src data :tangle ../tests/m-pos-01.txt
(x)(some y)(z)(f(x) = z iff z = y)
~(all x, y)[(f('a') = x /\ f(a) = y) implies x=y]

/* Group theory, per Jeffrey */
(x)(y)(z)(plus(x, plus(y, z)) = plus(plus(x, y), z))
(x)(plus(x, 0) = 0)
(x)(plus(x, minus(x)) = 0)
(forall x, y, z)(plus(x, y) = plus(y, z) implies x = y)
#+end_src

* Language L:  additional convenience features

Language L adds a number of convenience features to language M:
- typed quantifications (for all /x/ of type /T/, ...; there is
  some /x/ of type /T/ such that ...)
- unique existential quantification (there exists exactly one
  individual such that ...)
- Descriptions / Skolem expressions (the unique individual who ...)
- negated existential quantification (there is no /x/ such that ...)
- /lone/ existential quantification (there is at most one /x/ such
  that ...)

These are all intended as idioms for concise expression of commonly
used patterns; for each new construct, we specify a standard
translation into language M.

** New forms of quantification
Most of these changes have to do with quantifiers: allowing
them to specify the 'type' of the variable on one hand, and
allowing them to give more information about the number of
individuals involved on the other.  So instead of two forms
of quantification, we will have several:
  + universal
  + existential
  + unique
  + negated
  + lone
and for each of these, we'll have both typed and untyped varieties.
This will require some changes to the way quantified formulas are
defined, replacing the definitions from language S.

The new definitions are:
#+begin_src ixml :noweb-ref L-Quantification
{ Quantified formulas in L }
-quantified-formula = all | exist | one | none | lone.

all = universal-quantifier, os, bracketed-formula.
exist = existential-quantifier, os, bracketed-formula.
one = unique-existential-quantifier, os, bracketed-formula.
none = negated-existential-quantifier, os, bracketed-formula.
lone = lone-existential-quantifier, os, bracketed-formula.

-universal-quantifier = 
        -"(", FORALL, vars, os, type-spec?, -")"
      | -"(", os, one-var, os, type-spec?, -")"
      .
-FORALL = os, FORALL-sym, os
      | os, FORALL-lex, RS
      .

-existential-quantifier = 
        -"(", EXIST, vars, os, type-spec?, -")". 
-EXIST = os, EXIST-sym, os
      | os, EXIST-lex, RS
      .

@vars = var ++ comma-space.
@one-var > vars = var.
-comma-space = os, -",", os, +" ".
#+end_src

*** Typed quantification
In order to make some common kinds of statements more convenient, we
would like to be able to associate variables with classes, or types,
more or less as we can do in most programming languages.  To say, for
example, that all tokens occur in some document and that every
document contains at least one token, we can in language M write:
#+begin_example
(all k)(Token(k) 
       implies 
       (some d)(Document(d) and contains(d, k)))
(all d)(Document(d) 
       implies 
       (some k)(Token(k) and contains(d, k)))
#+end_example
It often seems simpler and easier to follow if instead we
write:
#+begin_src data :noweb-ref Typed-01
(all k: Token)(some d: Document)(contains(d, k))
(all d: Document)(some k: Token)(contains(d, k))
#+end_src

In our usage,
"~(∀x:T)(P(x))~" is just short-hand for
"~(∀x)(T(x) ⇒ P(x))~", and 
"~(∃x:T)(P(x))~" is just short-hand for
"~(∃x)(T(x) ∧ P(x))~".

The definitions of /universal-quantifier/ and /existential-quantifier/
given above allow for an optional type specification; the same will
be true of the other new forms of quantification.  A type specification
is just a colon followed by a name.  As illustrated above, this name
is taken as that of the characteristic predicate of the type.
#+begin_src ixml :noweb-ref Type-specification
-type-spec = -":", os, type, os.
@type = name.
#+end_src

Some more examples and test cases:
#+begin_src data :noweb-ref Typed-02
(∀x:T)(P(x))
(∃x:T)(P(x))
(∀x: Root)(Object(x))
(∀x: Root)(∀y: Root)(x = y)
(∀x: A)(Object(x))
(∀x: A)(∀y: A)(x = y)
(all x : Type)(~Token(x) and ~Document(x))
(all x : Token)(~Type(x) and ~Document(x))
(all x : Document)(~Type(x) and ~Token(x))
#+end_src

*** Unique existential quantification
Unique existential quantifiers assert the existence of exactly one
individual such that some proposition holds.

To say that every school has exactly one head teacher, one might say
"~(∀ s : School)(∃₁ h : Head-teacher)(heads(h, s))~".

Note:  Hughes and Cresswell write this (∃¹) or (∃!).

Syntactically, it's similar to the other quantifiers already seen: it
has both symbolic and alphanumeric forms, which have different
requirements with respect to following whitespace.
#+begin_src ixml :noweb-ref Unique-quantifier
unique-existential-quantifier = 
        -"(", EXISTS-ONE, vars, os, type-spec?, -")".
-EXISTS-ONE = os, EXISTS-ONE-sym, os
      | os, EXISTS-ONE-lex, RS
      .
@EXISTS-ONE-lex > op = "one" | "ONE"
      | "∃_1" 
      | "exists_1" | "EXISTS_1" 
      | "exist_1" | "EXIST_1" 
      | "E_1"
      .  
@EXISTS-ONE-sym > op = "∃₁" { #2203 + #2081 subscript one }.
#+end_src

For any variable quantified in this way, the declaration is
short-hand for a conjunction of statements following the pattern
established by Russell.  The table below shows the pattern
of expansion for typed and untyped examples of one and two
variables; for more variables, 
|------------------------+-----------------------------------------------|
| Shorthand              | Expansion                                     |
|------------------------+-----------------------------------------------|
| (∃₁x)(P(x))            | (∃x)(P(x) ∧ (∀y)(P(y) ⇒ x=y))                 |
|------------------------+-----------------------------------------------|
| (∃₁x:T)(P(x))          | (∃x)(T(x) ∧ P(x) ∧ (∀y)(T(y) ⇒ (P(y) ⇒ x=y))) |
|------------------------+-----------------------------------------------|
| (∃₁ x, y)(P(x, y))     | (∃x)(∃y)(P(x, y)                              |
|                        | ∧ (∀ z, w)(P(z, w) ⇒ (x=z ∧ y=w)))            |
|------------------------+-----------------------------------------------|
| (∃₁ x, y : T)(P(x, y)) | (∃x)(∃y)(T(x) ∧ T(y)                          |
|                        | ∧ P(x, y)                                     |
|                        | ∧ (∀ z, w)((T(z) ∧ T(y))                      |
|                        | ⇒ (P(z, w) ⇒ (x=z ∧ y=w))))                   |
|------------------------+-----------------------------------------------|

The final two examples in the table above can be read as saying that
there is just one combination of values for /x/ and /y/ such that
the properties given hold.

/To show:/ that the expansion given for a single unique quantification
over multiple variables is logically equivalent to the expansion of
nested unique quantifications.

Some examples:
#+begin_src data :noweb-ref Unique
(∃₁ x)(Root(x))
(one x)(A(x))
(exists_1 x)(B(x))
(all n : Node)(Root(n) or (one p : Node)(parent_child(p, n)))
(all p : Point)(exist_1 x, y: ℕ)
  (x = first(p) and y = second(p))
(exists_1 n : ℕ)(all m : ℕ)[le(n, m)]
#+end_src
*** Negated existential quantification
Experience with Alloy suggests that it's quite convenient to be able
to say concisely that there is no individual with some specified
property.

The formula "(no x)(P(x))" is strictly equivalent to "¬(∃x)(P(x))".
And "(no x : T)(P(x))" is strictly equivalent to "¬(∃x)(T(x) ∧ P(x))".

Because this quantifier is known to us only from Alloy, we
offer only one way to spell it.  (Well, two, since we allow
it to be in all caps.)
#+begin_src ixml :noweb-ref Negated-quantification
negated-existential-quantifier = 
        -"(", NONE, vars, os, type-spec?, -")".
-NONE = os, NONE-lex, RS.
@NONE-lex > op = "no"; "NO".
#+end_src

/To do:/ Describe the expansion for multiple variables, typed and
untyped, and explain whether it is or is not equivalent to nested
negated existential quantifiers for single variables.  That is: is (no
x, y : T)(P(x, y)) equivalent to (no x : T)(no y : T)(P(x, y)), or
not?

Examples:
#+begin_src data :noweb-ref Negated-existentials
/* subtoken relation is acyclic, or equivalently
   tc-subtoken relation is antisymmetric */
(no x : Token)(tc-subtoken(x, x))

/* there is no greatest natural number */
(no n : ℕ)(all m : ℕ)[ge(n, m)]
#+end_src
*** Lone existential quantification
This is another borrowing from Alloy.  It specifies that there is at
most one individual with the specified property: such an individual
may or may not exist, and if they do, then they are unique.

The syntax:
#+begin_src ixml :noweb-ref Lone-quantification
lone-existential-quantifier = 
        -"(", LONE, vars, os, type-spec?, -")".
-LONE = os, LONE-lex, RS.
@LONE-lex > op = "lone"; "LONE".
#+end_src

|-------------------------+-----------------------------------------------|
| Shorthand               | Expansion                                     |
|-------------------------+-----------------------------------------------|
| (lone x)(P(x))          | (∀x)(P(x) → (∀y)(P(y) ⇒ x=y))                 |
|-------------------------+-----------------------------------------------|
| (lone x: T)(P(x))       | (∀x)(T(x) ∧ P(x) → (∀y)((T(y) ∧ P(y)) ⇒ x=y)) |
|-------------------------+-----------------------------------------------|
| (lone x, y)(P(x, y))    | (∀ x, y)(P(x, y)                              |
|                         | → (∀ z, w)(P(z, w) ⇒ (x=z ∧ y=w)))            |
|-------------------------+-----------------------------------------------|
| (lone x, y: T)(P(x, y)) | (∀ x, y)((T(x) ∧ T(y) ∧ P(x, y))              |
|                         | ⇒ (∀ z, w)((T(z) ∧ T(y) ∧ P(z, w))            |
|                         | ⇒ (x=z ∧ y=w))))                              |
|-------------------------+-----------------------------------------------|

Some examples:
#+begin_src data :noweb-ref Lone-quantifiers
/* the digraph is connected:  at most one 
   node lacks incoming arcs */
(lone n : Node)(no p : Node)
    (parent_child(p, n))
/* Every mark is in at most one document */
(all m : Mark)(lone d : Document)(contains(d, m))
#+end_src

** Definite descriptions / Skolem expressions
Many treatments of logic discuss the problem of representing sentences
like "The present king of France is bald" -- and in particular of
representing terms like "the present king of France".  There then may
follow a discussion of Russell's analysis of the sentence as the
conjunction of (1) the claim that there is presently a king of France,
(2) the claim that there is only one such individual, and finally
(3) the claim that that individual is bald.  More formally:
#+begin_example
(∃x)(present-king-of-France(x)
    ∧ (∀y)(present-king-of-France(y) ⇒ x = y)
    ∧ bald(x))
#+end_example
This appears to be the consensus rendering of sentences involving
references to an individual by their properties (using descriptions
which are taken to identify some single individual) and not by their
name.

Some but not all treatments also introduce a more compact notation for
such sentences.  The unique existential quantifier introduced above
shortens the translation a bit:
#+begin_example
(∃₁x)(present-king-of-France(x)
    ∧ bald(x))
#+end_example
A further abbreviation introduces an operator written as an inverted
lowercase iota and uses the notation (℩x) to mean "the individual /x/
such that ...".  Using this notation, we can write
#+begin_example
bald((℩x)(present-king-of-France(x)))
#+end_example

On this notation, see Quine /Methods/ 274-282, and Hughes and
Cresswell 323-326.  Note, however, that while Russell and Quine use
℩-expressions as terms, Hughes and Cresswell treat expressions of the
form (℩xPx) as quantifiers binding /x/ in the following formula.
Their rendering of the example would be something like (℩x
present-king-of-France(x))(bald(x)) -- or more precisely (℩xφx)ψx,
with notes in prose saying that φ means 'is the present king of
France' and ψ means 'is bald'.

Terms written in this way allow us to refer to specific individuals
without giving them names, or without knowing what names may already
have been assigned to them; they also allow us to get rid of
existential quantifiers.  The same purpose is served in some contexts
by the process called Skolemization (at least in discussions of logic
programming).  In the Prolog theorem prover leanTAP, for example, the
formula (∃x)(f(x)) ("there is some /x/ such that /f/ holds of /x/") is
replaced with the formula f(f(ex)) ("/f/ holds of the individual for
whom /f/ holds").  And similarly (∃x)(p(x, y)) is translated to
p(p(ex,y), y).  In the notation declared here, we could write these as
f((℩x)[f(x)]) and p((℩x)[p(x,y)], y).  Note, however, that the Prolog
expressions do not claim uniqueness of the individual; that is one
way in which Skolemization differs from definite description.

It would be nice to find a way to write these expressions that fits
with the style used elswhere but gets by with fewer parentheses than
shown in the example above.  For now, however, we just accept Quine's
convention of wrapping the inverted iota and variable in one pair of
parentheses and the predicate that uniquely identifies x in a second.
As the examples given above have shown, we allow the following formula
to be enclosed in square brackets, not just round.
#+begin_src ixml :noweb-ref Descriptions
definite-description = IOTA, bracketed-formula.
@IOTA > op = -"(", IOTA-lex, RS, var, -")"
           | -"(", IOTA-sym, os, var, -")"
           .
IOTA-sym = "℩" { #2129 turned Greek small letter iota }.
IOTA-lex = "the".
#+end_src

We need to add definite descriptions as a kind of term.
#+begin_src ixml :noweb-ref L-Terms
{ L-Terms:  terms for individuals }
-term = var; 
        constant; 
        structure; 
        definite-description.
#+end_src

Some examples may help illustrate.
#+begin_src data :noweb-ref Test-cases-desc
/* Definite descriptions */
bald((℩x)(present-king-of-France(x)))
bald((the x)[present-king-of-France(x)])
f((℩x)[f(x)])
p( (℩x)[p(x,y)], y)
‹Scott› = (the x)(wrote-Waverley(x))
taught( (℩x)(philosopher(x) ∧ drank-hemlock(x)), 'Plato' )
#+end_src
** Recapitulation of language L
The grammar of language L can be summarized:
#+begin_src ixml :tangle l.ixml :noweb tangle
ixml version "1.1".

{ l.ixml:  grammar for first-order logic
  with identity and functions,  augmented
  with convenience features. }
m-formulas = os, formula++NL, os.
<<S-Formulas>>
<<XS-Compound-formulas>>

<<L-Quantification>>
<<Type-specification>>
<<Unique-quantifier>>
<<Negated-quantification>>
<<Lone-quantification>>

<<M-Basic-formulas>>
<<Identities>>
<<Bracketed-formulas>>

<<Predicates>>
<<XS-Atomics>>
<<L-Terms>>
<<S-Atomics>>
<<Structures>>
<<Descriptions>>
<<Quoted-strings>>

<<Logical-operators>>
<<Quantifier-ops>>

<<Basics>>
#+end_src

** Test cases for language L
We can collect all the examples given above and
use them as positive test cases for language L.
#+begin_src data :tangle ../tests/l-pos-01.txt :noweb tangle
<<Typed-01>>
<<Typed-02>>
<<Unique>>
<<Negated-existentials>>
<<Lone-quantifiers>>
<<Test-cases-desc>>
#+end_src
* Language XL: first-order logic plus set theory
It may be desirable to add another language to those defined here:
Language XL includes sets /(and tuples? tbd)/ in the universe of
discourse.

A severely minimal version of XL would add:
- the ability to declare variables as denoting sets of a given type
  (the equivalent of the Alloy declaration ~names:  set Name~)
- symbols for standard set operations (membership, complementation,
  union, intersection, subset relation, set difference)
- standard symbols for the empty set and the universal set

If we wish to have close equivalents to everything or most things in
Alloy, we will also add:
- syntax for tuples
- the ability to declare variables as denoting tuples in a given
  relation (with symbols allowing the user to distinguish total
  from partial functions, injections, and bijections) 
- set comprehensions
- sequences as mappings from a prefix of the natural numbers to items
- natural numbers (or integers more generally)
- standard names for functions which return the domain and range of
  relations
- ... and more.

An even larger language would result from adding additional constructs
present in languages like Z.

The inclusion of tuples, set comprehensions, and various forms of
functions and relations is uncertain.  It may be desirable to exclude
them for simplicity and reliability, since the ground has proved so
treacherous for so many.  But it may be that once sets are added, we
have tuples and relations whether we want them or not.  And in that
case, we might as well have set comprehensions to make them easier to
talk about.

At the time this document was drafted, there seems to be no urgent
need for a definition of language XL; the uncertainty about what it
should contain is perhaps a consequence of the fact that we don't have
a concrete use in mind for it.

* Concluding notes
The grammars defined here have two intended functions:
- They provide specific targets for programs we write
  which are to translate some notation or other into
  'conventional first-order logic'.  That is, they allow
  that vague description to be replaced by a statement
  that the program's output is or should be sentences
  in one of the languages defined here.
- They make it easy to translate formulas into XML form
  so they can be processed by XSLT or XQuery programs.  
  We may write pretty-printers, normalizers, and (of course)
  translations into specific target notations like ACL2
  or TPTP FOF or TFF.

At first glance, it may seem excessive to formulate test cases for
such a simple collection of grammatical rules.  But the tests have
caught a number of errors in the grammar.

# ** To do
# Watch this space.

** Questions to consider
At the time this paper was last revised (May 2024 or later), several
questions seemed to merit further consideration.  They are not
strictly speaking open questions, in so far as the grammars given here
provide specific answers to them.  But they are questions in whose
answers the authors do not currently feel completely confident.  Those
we remembered to write down are:

- Q. Should subscripts be allowed in identifiers?

  A. In some sense, they already are.  The only effective way to allow
  subscripts is to provide some convenient typographic shorthand for
  them; the obvious choice is to separate the base name from the
  subscript with an underscore: thus /x/ with a subscribt of 1 can be
  written ~x\zwnj{}_1~, which can in HTML or on paper be formatted as
  /x_1/.  But this is already allowed.

  Perhaps underscore should be allowed in identifiers /only/ with the
  meaning 'subscript'?  And thus only when followed by decimal digits?

  Tentative answer:  unnecessary.

- Q. Include an explicit notation for tuples in language XL?

- Q. Include explicit notation(s) for sequences in language XL?

- Q. Define variant grammars with less variation in the spelling of
  operators?

  Tentative answer: unnecessary.  Consistency of spelling is important
  for presentation, but not for ingestion of formulas.  A normalizer
  can easily be written to reserialize formula sequences in any
  desired form with consistent spelling (and optionally
  pretty-printing).

- Add /xor/ (aka /aut/), /nand/, /nor/ to language L?
  
- Eliminate propositional variables and propositional constants in S
  through XL / allow them only in XS?

- Allow variables to begin with "~$~"?

- Allow other forms of numbers as individual constants? (Currently
  only unsigned integers are allowed.  And it's only the sentence
  about Frege being born in 1848 that motivates that.)

- Are we sure we want to allow negation to bind more tightly than the
  binary operators?

  I got tired of having add parentheses, so I added negation as a
  'basic' formula.  We need to think about it more when we have more
  experience.

- In L, borrow Alloy's ability to specify that particular variables
  are disjoint?

- Accept (∃¹), (∃^1), and/or (∃!) as input forms for unique
  existential quantifiers, following Hughes and Cresswell?

- Find a form for iota-expressions that uses fewer parentheses?

- All TLA+-style quantification of the form "∀ /x/ : /p/" and "∃ /x/ ∈
  /S/ : /p/"?  That is: allow quantifiers to be separated from the
  governed proposition not by parentheses but by a colon?  And allow
  variable and type to be separated not by colon but by "∈"?

  Note that the current form of typed quantifiers would need to
  change, since otherwise "~all x : P~" would require more lookahead
  than we would like and would be easy to misread, even if not
  strictly speaking ambiguous.
  
** Done
Temporary list of to-do items now completed.
- Split all operators into symbolic and alphabetic forms.
  Adjacent space is optional for symbolic form, required
  for alphabetics.  I think this works already for quantifiers,
  but the current grammar allows ~born('Frege', 1848)~ to be
  parsed either as intended or as equivalent to
  ~b ∨ n('Frege', 1848)~, which is going too far.
- Create minimal test case exhibiting /vars/ problem, report
  to Markup Blitz.
  
  


* References

Beckert, Bernhard, and Joachim Posegga. "LeanTAP: Lean Tableau-based
Deduction." /Journal of Automated Reasoning/ 15 (1995): 339–358.

Hughes, G. E., and M. J. Cresswell.  /A new introduction to modal logic./
London and New York:  Routledge, 1996 (rpt. 1998, 2001).

Jackson, Daniel.  /Software abstractions: Logic, language, and
analysis./ Revised edition.  Cambridge, Mass.:  MIT Press, 2012.

Jeffrey, Richard C. /Formal logic: Its scope and limits./ New York:
McGraw-Hill, 1967.

Quine, Willard Van Orman.  /Elementary logic./ 1941. Revised
Edition. Cambridge, Mass.: Harvard University Press, 1980.

Quine, W. V. /Methods of logic./ 1950.  Fourth edition.  Cambridge, Mass.:
Harvard University Press, 1982.

Smullyan, Raymond M. /First-order logic./ New York: Springer, 1968.
Corrected repring New York: Dover, 1995.

Sutcliffe, Geoff ... TPTP technical manual.

Sutcliffe, Geoff, et al.  Paper on TFF.

Sutcliffe, G., Kotelnikov, E.: TFX: the TPTP extended typed first-order form. In: Konev, B., Urban, J., Rümmer, P. (eds.) Proceedings of the 6th Workshop on Practical Aspects of Automated Reasoning (PAAR), Oxford, UK. CEUR Workshop Proceedings, vol. 2162, pp. 72–87 (2018). http://ceur-ws.org/Vol-2162/#paper-07

Sutcliffe, G., Schulz, S., Claessen, K., Baumgartner, P.: The TPTP typed first-order form with arithmetic. In: Bjørner, N., Voronkov, A. (eds.) LPAR 2012. LNCS, vol. 7180, pp. 406–419. Springer, Heidelberg (2012). https://doi.org/10.1007/978-3-642-28717-6_32
