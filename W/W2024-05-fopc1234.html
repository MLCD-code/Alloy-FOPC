<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-05-23 Thu 16:49 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Five varieties of first-order predicate calculus</title>
<meta name="author" content="CMSMcQ and CH" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Five varieties of first-order predicate calculus</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#org0e2da60">1. Design goals and design decisions</a></li>
<li><a href="#org3db4f01">2. Language XS:  sentential logic</a>
<ul>
<li><a href="#orgc29d2bd">2.1. Basics: Names, whitespace, comments</a>
<ul>
<li><a href="#org770fc19">2.1.1. Names</a></li>
<li><a href="#orgbf30170">2.1.2. Whitespace</a></li>
<li><a href="#org274d070">2.1.3. Comments</a></li>
<li><a href="#org6bd2622">2.1.4. Recapitulation (comments)</a></li>
</ul>
</li>
<li><a href="#org5db8eaa">2.2. Propositional variables and constants</a></li>
<li><a href="#org407e593">2.3. Formulas</a></li>
<li><a href="#orgf69aa36">2.4. Logical Operators</a></li>
<li><a href="#org215b4cd">2.5. Recapitulation</a></li>
<li><a href="#orgb589eec">2.6. Tests</a></li>
</ul>
</li>
<li><a href="#orgd98042b">3. Language S:  first-order logic</a>
<ul>
<li><a href="#orgb687815">3.1. Note on different uses of identifiers</a></li>
<li><a href="#orgcedf164">3.2. Variables and constants</a></li>
<li><a href="#orgcb42580">3.3. Predicates</a></li>
<li><a href="#orgd02453d">3.4. Quantification</a></li>
<li><a href="#orgee67e78">3.5. Formulas</a></li>
<li><a href="#org756d594">3.6. Recapitulation of language S</a></li>
<li><a href="#orgf63b67b">3.7. Tests for language S</a></li>
</ul>
</li>
<li><a href="#org8d45f17">4. Language M:  first-order logic with identity and functions</a></li>
<li><a href="#orgf2e4ec6">5. Language L:  additional convenience features</a></li>
<li><a href="#org4d7edb8">6. Language XL: first-order logic plus set theory</a></li>
<li><a href="#org58d9e89">7. Concluding notes</a>
<ul>
<li><a href="#org62112d1">7.1. To do</a></li>
<li><a href="#orga50b318">7.2. Questions to consider</a></li>
<li><a href="#orgbd05d0c">7.3. Done</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
This document describes several languages for the expression of
logical formulas, each containing the preceding.  For convenient
reference, the languages are given names chosen to suggest their
relative sizes:
</p>

<ul class="org-ul">
<li><b>XS</b> (extra-small), the first language, is for sentential logic.</li>
<li><b>S</b> (small) is for first-order logic without identity.</li>
<li><b>M</b> (medium) is for first-order logic with functions and identity.
We believe but have not undertaken to prove that M is equivalent to
the TPTP language of first-order formulas, FOF.</li>
<li><b>L</b> (large) adds some convenience features: typed quantification,
unique existential quantification, and skolem functions.  It is at
least roughly comparable to the TFF (typed first-order formulas)
language of TPTP.</li>
<li><b>XL</b> (extra-large) adds sets and set operations.  <i>Open question:
add tuples?</i></li>
</ul>

<div id="outline-container-org0e2da60" class="outline-2">
<h2 id="org0e2da60"><span class="section-number-2">1.</span> Design goals and design decisions</h2>
<div class="outline-text-2" id="text-1">
<p>
One goal of the paper is to provide a more precise description of the
target language(s) for our work translating Alloy models into
first-order logic.
</p>

<p>
A secondary goal is to provide a convenient syntax for presentation
and discussion of formulas that is as far as possible agnostic on the
particular symbols used for quantification and logical operators.
Textbooks on logic are notoriously divergent in their choices of
symbols, and so are those who publish papers containing logical
formulas.  Software for dealing with formulas is equally various in
its choices.  We see no reason to insist that logical conjunction be
expressed with "&amp;" but not with "/\" or "∧" or even just "and", and so
on.
</p>

<p>
Because different people seem to have different intuitions about which
logical operators should bind more tightly and which less tightly, we
do not attempt an elaborate set of operator priorities.  We allow (A
and (B and C)) to be writte (A and B and C), and similarly for (A or
(B or C)), but otherwise all nested compound expressions must be
parenthesized.  (This is a change from the grammar we worked on in
2021 and 2022.)
</p>

<p>
To avoid possible confusion over the scope of quantifiers, the same
rule applies to quantifications: we can write ∃x P(x), or (∃x)P(x),
but if the quantifier's scope includes an operator, parentheses are
needed:  ∃x (P(x) ∧ Q(x)).
</p>

<p>
We assume that for applications of logic to a domain (what Quine calls
post-foundational systems), it is important for identifiers to be
mnemonic, and (thus) that identifiers will often be longer than one
character.  
</p>
</div>
</div>

<div id="outline-container-org3db4f01" class="outline-2">
<h2 id="org3db4f01"><span class="section-number-2">2.</span> Language XS:  sentential logic</h2>
<div class="outline-text-2" id="text-2">
<p>
Language XS is for sentential logic.
</p>
</div>

<div id="outline-container-orgc29d2bd" class="outline-3">
<h3 id="orgc29d2bd"><span class="section-number-3">2.1.</span> Basics: Names, whitespace, comments</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The basic symbols of the language are Unicode characters.
</p>
</div>

<div id="outline-container-org770fc19" class="outline-4">
<h4 id="org770fc19"><span class="section-number-4">2.1.1.</span> Names</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
A name is a sequence of characters beginning with a letter and containing
only letters, numeric digits, hyphens, and underscores.
</p>
<div class="org-src-container">
<pre class="src src-ixml" id="org9425f8c">name = letter, namechar*.
-letter = [L].
-namechar = letter; digit; ["-_"].
-digit = [Nd].
</pre>
</div>

<p>
Example names:
</p>
<pre class="example" id="orgd2e9a38">
p
q
Prop-2a
φ
</pre>
</div>
</div>

<div id="outline-container-orgbf30170" class="outline-4">
<h4 id="orgbf30170"><span class="section-number-4">2.1.2.</span> Whitespace</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
Whitespace is any member of Unicode class Zs (Separator, space), as
well as a few control characters.  Required space is one or more
whitespace characters or comments; optional space is zero or more.
</p>
<div class="org-src-container">
<pre class="src src-ixml" id="org2d6a750">-whitespace = -[Zs; #9; #A; #D].
-RS = (whitespace; comment)+.
-os = (whitespace; comment)*.
{ NL for required line breaks }
-NL = (-[Zs; #9] | comment)*, #A, os.
</pre>
</div>
</div>
</div>

<div id="outline-container-org274d070" class="outline-4">
<h4 id="org274d070"><span class="section-number-4">2.1.3.</span> Comments</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
A comment is a string of characters beginning with "&zwnj;/&zwnj;*"
(slash + asterisk) and ending with "&zwnj;*&zwnj;/" (asterisk + slash).
Comments may contain other comments, but not unmatched occurrences of
those delimiter strings.  Experience shows that this can easily be
formulated wrong, so we will start with a step-by-step development.
Within the comment, we can be in any of several states:
</p>
<ul class="org-ul">
<li><b>default</b>: the default state: nothing special has happened &#x2013; in
particular, we have not seen a star or a slash.  In this state,
several things can happen:
<ul class="org-ul">
<li>The empty string is acceptable (i.e. this can be the last state
of the comment data.)</li>
<li>A character other than slash or asterisk returns us to this state.</li>
<li>A nested comment returns us to this state.</li>
<li>A slash that does not start a nested comment takes us to state
<b>slash-seen</b>.</li>
<li>An asterisk not followed by a slash takes us to state <b>star-seen</b>.</li>
</ul></li>
<li><b>star-seen</b>:  we have seen an asterisk, and must not see a slash
next.  (If a slash is next, this is the wrong state.)
<ul class="org-ul">
<li>The empty string is acceptable (i.e. this can be the last state
of the comment data).</li>
<li>An asterisk that is not part of the comment-closing delimiter
returns us to this state.</li>
<li>Any character other than a slash or an asteriak returns us to
the <b>default</b> state.</li>
</ul></li>
<li><b>slash-seen</b>:  we have seen a slash, and must not now see an asterisk.
(If an asterisk is next, this is the wrong state.)
<ul class="org-ul">
<li>The empty string is not acceptable; this must <i>not</i> be the last
state of the comment data (since the closing delimiter starts
with the asterisk, which we must not see).</li>
<li>A nested comment returns us to the <b>default</b> state.</li>
<li>A slash that does not start a comment returns us to this state.</li>
<li>Any character other than a slash or star returns us to the
<b>default</b> state.</li>
</ul></li>
</ul>

<p>
We can describe this with a pseudo-regular grammar for <i>comment-data</i>.
(Why "pseudo-regular"?  like a regular grammar, it has rules whose
right-hand sides have a single symbol followed by a non-terminal
naming the next state, but it is not truly regular because <i>comment</i>
is not a terminal symbol; it's just treated as if it were one.)
</p>

<div class="org-src-container">
<pre class="src src-ixml">      comment = "/*", comment-data, "*/".
 comment-data = default-state.
default-state = ()
              | ~["/*"], default-state
              | comment, default-state
              | "/", slash-seen
              | "*", star-seen
              .
    star-seen = ()
              | "*", star-seen
              | ~["/*"], default-state
              .
   slash-seen = comment, default-state
              | "/", slash-seen
              | ~["/*"], default-state
              .
</pre>
</div>

<p>
The rules for <i>star-seen</i> and <i>slash-seen</i> can be simplified by
applying Arden's Lemma. (<i>A = X, A; B.</i> can be rewritten <i>A = X*, B.</i>)
</p>
<div class="org-src-container">
<pre class="src src-ixml">default-state = ()
              | ~["/*"], default-state
              | comment, default-state
              | "/", slash-seen
              | "*", star-seen
              .          
   star-seen = "*"*, (~["/*"], default-state)?.
  slash-seen = "/"*, (comment | ~["/*"]), default-state.
</pre>
</div>

<p>
Now the references to <i>star-seen</i> and <i>slash-seen</i> can be expanded
in place.  We then replace the right-hand side beginning with "*" 
with two simpler right-hand sides.
</p>
<div class="org-src-container">
<pre class="src src-ixml">default-state = ()
              | ~["/*"], default-state
              | comment, default-state
              | "/", "/"*, (comment | ~["/*"]), default-state
              | "*", "*"*, ~["/*"], default-state
              | "*", "*"*
              .          
</pre>
</div>

<p>
Further simplification produces:
</p>
<div class="org-src-container">
<pre class="src src-ixml">default-state = "/"*, (comment | ~["/*"]), default-state
              | "*"+, ~["/*"], default-state
              | "*"*
              .          
</pre>
</div>

<p>
We can now apply Arden's Lemma to <i>default-state</i> to
produce a single rule for comment data.
</p>
<div class="org-src-container">
<pre class="src src-ixml">default-state = ("*"+, ~["/*"] | "/"*, (comment | ~["/*"]))*, "*"*.          
</pre>
</div>

<p>
With that development providing some confidence in the
rule, we can write the comment rules for real now:
</p>
<div class="org-src-container">
<pre class="src src-ixml" id="org20c9ae3">      comment = -"/*", comment-data, -"*/".
-comment-data = ("*"+, ~["/*"] 
                | "/"*, (comment | ~["/*"]))*, 
                "*"*.
</pre>
</div>

<p>
This is complicated enough that it may be worth writing down
some positive and negative test cases.  Positive examples include:
</p>
<div class="org-src-container">
<pre class="src src-data">/**/
/* */
/* this is a comment */
/* *this* example/test case contains nested stars and a slash (/) */
/*/* a nested comment*/ and more*/
/*/* a nested comment*/*** and ////* another */*/
/*******/
/*//////* test */  ***/
</pre>
</div>

<p>
Negative examples:
(1) An asterisk followed by a slash.
</p>
<div class="org-src-container">
<pre class="src src-data">/* A slash (*/*) cannot be emphasized here. */
</pre>
</div>
<p>
(2) Comment data ending with a slash.
</p>
<div class="org-src-container">
<pre class="src src-data">/*///*/
</pre>
</div>

<p>
An ad-hoc test grammar will allow us to run these test cases:
</p>
<div class="org-src-container">
<pre class="src src-ixml">tests = (whitespace; comment)*.
&lt;&lt;Comments&gt;&gt;
&lt;&lt;Whitespace&gt;&gt;
</pre>
</div>

<p>
These tests can be run manually in a shell:
</p>
<pre class="example" id="orgca59a52">
for f in comments-*.txt ; \
    do markup-blitz.sh $f comment-tests.ixml ${f%.txt}.xml; \
    done
</pre>
<p>
I have no automatic checking of results:  the positive
examples should produce XML results which look plausible,
and the negative examples should all fail to parse.  A quick
check can be done with
</p>
<pre class="example" id="org10e4438">
grep ixml:state comments-*.xml
</pre>
</div>
</div>

<div id="outline-container-org6bd2622" class="outline-4">
<h4 id="org6bd2622"><span class="section-number-4">2.1.4.</span> Recapitulation (comments)</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
We can sum up these low-level rules thus:
</p>
<div class="org-src-container">
<pre class="src src-ixml" id="org4830bdf">
{ Basics:  names, whitespace, comments }
name = letter, namechar*.
-letter = [L].
-namechar = letter; digit; ["-_"].
-digit = [Nd].
-whitespace = -[Zs; #9; #A; #D].
-RS = (whitespace; comment)+.
-os = (whitespace; comment)*.
{ NL for required line breaks }
-NL = (-[Zs; #9] | comment)*, #A, os.
      comment = -"/*", comment-data, -"*/".
-comment-data = ("*"+, ~["/*"] 
                | "/"*, (comment | ~["/*"]))*, 
                "*"*.
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org5db8eaa" class="outline-3">
<h3 id="org5db8eaa"><span class="section-number-3">2.2.</span> Propositional variables and constants</h3>
<div class="outline-text-3" id="text-2-2">
<p>
A propositional variable is a name.
</p>

<p>
In language XS, a propositional constant is a name enclosed in single
quotes.  In practice, we'll use typewriter apostrophes, but to allow
formulas to be copy-pasted from contexts which use proper quotation
marks, typeset quotation marks are also allowed (<code>‘...’</code>, <code>‹...›</code>,
<code>›...‹</code>), as are (sigh) TeX-style single quotation marks (<code>`...'</code>).
We allow single guillemets in either order, because both
inward-pointing pairs and outward-pointing pairs are used.  (We have
seen claims that one is French practice and the other German practice,
but we believe we have seen both forms in German typesetting.)
</p>

<div class="org-src-container">
<pre class="src src-ixml" id="orgf4e03c2">{ XS Atomics:  propositional variables and constants }
prop-var = @name.
prop-constant = quoted-name; quoted-string.
-quoted-name = -#27, @name, -#27 
               { #27 is typewriter apostrophe }
             | -#60, @name, -#27 
               { #60 is typewriter grave accent }
             | -#2018, @name, -#2019 
               { hi 6, hi 9 }
             | -#203A, @name, -#2039 
               { single guillemets pointing in }
             | -#2039, @name, -#203A 
               { single guillemets pointing out }
             .
</pre>
</div>

<p>
At this point, I am mildly tempted to allow arbitrary one-line strings
enclosed in double quotes, so as to make <code>"Socrates is a Greek."</code> and
<code>"All Greeks are mortal."</code> allowable as propositional constants.  And,
after all, why not?
</p>
<div class="org-src-container">
<pre class="src src-ixml" id="org72e7180">@quoted-string
      &gt; string = -#22, (~[#22; #A]; (#22, #22))*, -#22
               | -#60, -#60, ~[#22; #60; #A]*, -#27, -#27 
               | -#60, -#60, ~[#22; #60; #A]*, -#22 
               | -#201C, ~[#201C; #201D; #A]*, -#201D
               | -#AB, ~[#AB; #BB; #A]*, -#BB
               | -#BB, ~[#AB; #BB; #A]*, -#AB
               .
</pre>
</div>
<p>
For the record:
</p>
<ul class="org-ul">
<li>#22 is a straight typewriter double quotation mark.</li>
<li>#60 is a grave accent, often used doubled for
a left double quotation mark by TeX users.</li>
<li>#201C and #201D are typeset double quotation marks
conventional in English-language typesetting
(high 66, high 99).</li>
<li>#AB and #BB are left- and right-pointing guillemets.
We allow them to be paired pointing in or pointing
out, because both styles may be encountered in
European typesetting.</li>
</ul>

<p>
In the first form of quoted string, a double quotation mark in the
string may be represented by two double quotation marks in a row.  We
have not bothered with similar escape mechanisms in the other forms.
</p>
</div>
</div>

<div id="outline-container-org407e593" class="outline-3">
<h3 id="org407e593"><span class="section-number-3">2.3.</span> Formulas</h3>
<div class="outline-text-3" id="text-2-3">
<p>
In language XS, a basic formula is a propositional variable, a propositional
constant, or a formula enclosed in parentheses.  We allow both round parentheses
and square brackets, to ease the reading of complex formulas.
</p>

<div class="org-src-container">
<pre class="src src-ixml">{ XS Basic formulas }
-basic-formula = prop-var | prop-constant 
               | -"(", os, -formula, os, -")"
               | -"[", os, -formula, os, -"]".
</pre>
</div>

<p>
A <i>formula</i> in general is a basic formula or one of several kinds of
compound formulas.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ XS Formulas in general }
formula = basic-formula | compound-formula.
-compound-formula = not | and | or | implies | iff.
</pre>
</div>

<p>
Each logical operator defines a distinct type of compound formula.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ Compound formulas }
    not = NOT+, basic-formula.
    and = basic-formula++AND, AND, (basic-formula | not).
     or = basic-formula++OR,  OR,  (basic-formula | not).
implies = basic-formula, IMPLIES, (basic-formula | not).
    iff = basic-formula, IFF, (basic-formula | not).
</pre>
</div>

<p>
Note that <i>not</i>, <i>and</i>, and <i>or</i> all allow multiple repetitions of the
operator without parentheses.  Since <i>and</i> and <i>or</i> are associative,
expressions like <i>A ∧ (B ∧ C)</i> and <i>(A ∧ B) ∧ C</i> always have the same
truth value, so there is no reason to require parentheses to specify
one structure or the other.
</p>

<p>
For conditionals and biconditionals, however, the left- and
right-associative interpretations of expressions like <i>A implies B
implies C</i> or <i>A iff B iff C</i> are not equivalent.  If there were a
principled, easily remembered rationale for choosing left or right
associativity, it would make sense to chose one or the other.  But we
see no such rationale.  To avoid confusion, we require parentheses
around nested occurrences of <i>implies</i> and <i>iff</i>.
</p>

<p>
For the <i>not</i> operator, there is only one imaginable structure, so the
parentheses in an expression like <i>¬(¬(¬p))</i> are optional.  Similarly,
the scope of a negation symbol is clear if it applies to the
right-most operand of an <i>n</i>-ary or binary operator.  So <i>not</i>
expressions are allowed in those positions.  As a result, the
parentheses are necessary in <code>(¬p)∨q</code> and <code>¬(p∨q)</code> &#x2013; the
expression <code>¬p∨q</code> is ungrammatical &#x2013; but no parentheses are needed
in <code>p∨¬q</code>.
</p>

<p>
We might wish to consider adding other operators: <i>xor</i> (or <i>aut</i>),
<i>nor</i>, <i>nand</i>.  But since we do not want those operators in language
M, and we want M to be a proper superset of XS, we leave them out.
</p>
</div>
</div>

<div id="outline-container-orgf69aa36" class="outline-3">
<h3 id="orgf69aa36"><span class="section-number-3">2.4.</span> Logical Operators</h3>
<div class="outline-text-3" id="text-2-4">
<p>
For each operator, we seek to allow a wide variety of different forms:
symbols used in logic textbooks, symbols and keywords used in systems
like Alloy or TLA+ or Z, symbols, keywords, and character sequences
used in combination programming language / theorem provers like ACL2,
Lean, and Agda.  <i>Not</i> included: operators for C.
</p>

<p>
For the record, a survey of some sources shows the following:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Source</th>
<th scope="col" class="org-left">not</th>
<th scope="col" class="org-left">and</th>
<th scope="col" class="org-left">or</th>
<th scope="col" class="org-left">implies</th>
<th scope="col" class="org-left">iff</th>
<th scope="col" class="org-left">forall</th>
<th scope="col" class="org-left">exists</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Jeffrey</td>
<td class="org-left">—</td>
<td class="org-left">&amp;</td>
<td class="org-left">∨</td>
<td class="org-left">→</td>
<td class="org-left">↔</td>
<td class="org-left">(x)</td>
<td class="org-left">(∃x)</td>
</tr>

<tr>
<td class="org-left">unnamed*</td>
<td class="org-left">~, ⁓</td>
<td class="org-left">·</td>
<td class="org-left">+</td>
<td class="org-left">⊃</td>
<td class="org-left">≡</td>
<td class="org-left">⋀x, Πx</td>
<td class="org-left">⋁x, Σx</td>
</tr>

<tr>
<td class="org-left">Quine 1941</td>
<td class="org-left">⁓, p̄</td>
<td class="org-left">·</td>
<td class="org-left">∨</td>
<td class="org-left">⊃</td>
<td class="org-left">≡</td>
<td class="org-left">(x)</td>
<td class="org-left">(∃x)</td>
</tr>

<tr>
<td class="org-left">Smullyan</td>
<td class="org-left">⁓</td>
<td class="org-left">∧</td>
<td class="org-left">∨</td>
<td class="org-left">⊃</td>
<td class="org-left">↔</td>
<td class="org-left">∀x</td>
<td class="org-left">∃x</td>
</tr>

<tr>
<td class="org-left">Quine 1950</td>
<td class="org-left">—, p̄</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">∨</td>
<td class="org-left">→</td>
<td class="org-left">↔</td>
<td class="org-left">∀x</td>
<td class="org-left">∃x</td>
</tr>

<tr>
<td class="org-left">Alloy</td>
<td class="org-left">not</td>
<td class="org-left">and</td>
<td class="org-left">or &zwnj;</td>
<td class="org-left">implies</td>
<td class="org-left">iff</td>
<td class="org-left">all x</td>
<td class="org-left">some x</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">!</td>
<td class="org-left">&amp;&amp;</td>
<td class="org-left">&vert;&vert; &zwnj;</td>
<td class="org-left">&zwnj;=&gt;</td>
<td class="org-left">&lt;=&gt;</td>
<td class="org-left">all x</td>
<td class="org-left">some x</td>
</tr>

<tr>
<td class="org-left">TLA+</td>
<td class="org-left">¬</td>
<td class="org-left">∧</td>
<td class="org-left">∨</td>
<td class="org-left">⇒</td>
<td class="org-left">≡</td>
<td class="org-left">∀x</td>
<td class="org-left">∃x</td>
</tr>

<tr>
<td class="org-left">TLA+ ASCII</td>
<td class="org-left">~</td>
<td class="org-left">/\</td>
<td class="org-left">\/</td>
<td class="org-left">﻿=&gt;</td>
<td class="org-left">&lt;=&gt;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">\lnot</td>
<td class="org-left">\&zwnj;land</td>
<td class="org-left">\&zwnj;lor</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\&zwnj;equiv</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">\&zwnj;neg</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Agda ASCII</td>
<td class="org-left">\&zwnj;lnot</td>
<td class="org-left">\&zwnj;and</td>
<td class="org-left">\&zwnj;or</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">\&zwnj;neg</td>
<td class="org-left">\&zwnj;wedge</td>
<td class="org-left">\&zwnj;vee</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
,* Notes:
</p>
<ul class="org-ul">
<li>The row labeled 'unnamed' is from Jeffrey's appendix on notation.</li>
<li>Quine 1941 is <i>Element logic</i>, revised edition.</li>
<li>Smullyan is <i>First-order logic</i>.</li>
<li>Quine 1950 is <i>Methods of logic</i>. Conjunction is expressed by
juxtaposition (and identifiers for propositions are in consequence
restricted to single characters).</li>
<li>Alloy also allows double bar (<code>||</code>) for disjunction.  It defines
the additional quantifiers <b>no</b>, <b>lone</b>, and <b>one</b>.</li>
<li>Agda presumably does have an implication symbol (and equivalence,
and so on), but I have not progressed far enough to know what it is.</li>
</ul>

<p>
Quine notes that swung dash (⁓) sometimes is used with the
meaning 'iff'.
</p>

<div class="org-src-container">
<pre class="src src-ixml">{ Logical operators }
@NOT &gt; op = NOT-sym, os
          | NOT-alpha, RS
          .
NOT-alpha = "not" | "NOT".
  NOT-sym = "¬" { #AC not sign }
          | "-"
          | "—" { #2014 em dash }
          | "~" { #7E tilde }
          | "⁓" { #2053 swung dash }
          . 

@AND &gt; op = os, AND-sym, os
          | RS, AND-alpha, RS
          .
AND-alpha = "and" | "AND"
          | "\land" | "\and" 
          | "\wedge"
          .
  AND-sym = "∧" { #2227 }
          | "&amp;"
          | "&amp;&amp;"
          | "/\" { emacs here wants a " }
          .

 @OR &gt; op = os, OR-sym, os
          | RS, OR-alpha, RS
          .
 OR-alpha = "or" | "OR" 
          | "vel" | "VEL" 
          | "\lor" | "\or" | "\vee"
          .
   OR-sym = "∨" { #2228 logical or }
          | "|" 
          | "||"
          | "\/"
          . 
@IMPLIES &gt; op = os, IMPLIES-sym, os
              | RS, IMPLIES-alpha, RS. 
IMPLIES-alpha = "implies" | "IMPLIES" 
              | "only", os, "if" 
              | "ONLY", os, "IF"
              .
  IMPLIES-sym = "⇒" { #21D2 right double arrow } 
              | "⊃" { #2283 superset of }
              | "→" { #2192 right arrow }
              | "-&gt;"
              | "=&gt;"
              .

@IFF &gt; op = os, IFF-sym, os
          | RS, IFF-alpha, RS.
IFF-alpha = "iff" | "IFF"; "\equiv".
  IFF-sym = "⇔" { #21D4 left right double arrow }
          | "↔" { #2194 left right arrow }
          | "≡" { #2261 identical to }
          | "&lt;-&gt;"
          | "&lt;=&gt;"
          .
</pre>
</div>
</div>
</div>
<div id="outline-container-org215b4cd" class="outline-3">
<h3 id="org215b4cd"><span class="section-number-3">2.5.</span> Recapitulation</h3>
<div class="outline-text-3" id="text-2-5">
<p>
The entire XS grammar can now be summarized:
</p>
<div class="org-src-container">
<pre class="src src-ixml">ixml version "1.1".

{ xs.ixml:  grammar for sentential logic }
xs-formulas = os, formula++NL, os.
&lt;&lt;XS-Formulas&gt;&gt;
&lt;&lt;XS-Compound-formulas&gt;&gt;
&lt;&lt;XS-Basic-formulas&gt;&gt;

&lt;&lt;XS-Atomics&gt;&gt;
&lt;&lt;Quoted-strings&gt;&gt;

&lt;&lt;Logical-operators&gt;&gt;

&lt;&lt;Basics&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgb589eec" class="outline-3">
<h3 id="orgb589eec"><span class="section-number-3">2.6.</span> Tests</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Some simple positive tests for language XS follow.
First, some propositional variables.
</p>
<div class="org-src-container">
<pre class="src src-data">/* Some basic formulas */
/* Propositional variables */
p
q
Prop-2a
φ
א
/* and */
</pre>
</div>
<p>
Note that the string "and" is a propositional
variable as well as a logical operator for
conjunction. Parsed as a formula, however, it
can only be the latter.  In the context "A and B"
or "p and q", it can only be the former.
(In the test context, it can be either, however,
so I commented it back out.)
</p>

<p>
Then, some propositional constants.
</p>
<div class="org-src-container">
<pre class="src src-data">/* Propositional constants */
'Prop-2a'
›Frege-was-born-in-1848‹
‹Russell-died-in-1970›
`Prop-2b'

/* Double-quoted strings as propositional constants */
"Frege was born in 1848"
``he is at his desk''
“he is eating lunch”
</pre>
</div>

<p>
Then, some propositional constants.
</p>
<div class="org-src-container">
<pre class="src src-data">/* Parenthesized basic formulas */
(q)
( Prop-2a )
[(φ)]
['Prop-2a' ]
</pre>
</div>

<p>
And now, finally, some compound formulas:
</p>
<div class="org-src-container">
<pre class="src src-data">/* Compound formulas */
(p iff (q&amp;r)) only if (p &amp;&amp; q)
(p implies (q &amp; r)) iff (p ∧ q)
(p ∨ q) implies r
p ∨ (q implies r)
p implies (q or r)
"Jones is here" and "Smith is away"
[([(p∨q) ∧ (p∨-q)] ∨ [(-p)∧q]) ⇔ q] ⇒ [(p∧r) ∨ (p∧~r)]
</pre>
</div>

<p>
Bringing all the positive examples together,
we have:
</p>
<div class="org-src-container">
<pre class="src src-data">&lt;&lt;XS-Tests-vars&gt;&gt;
&lt;&lt;XS-Tests-constants&gt;&gt;
&lt;&lt;XS-Tests-parens-basic&gt;&gt;
&lt;&lt;XS-Tests-compounds&gt;&gt;
</pre>
</div>
<p>
Some negative examples should be added.  But for
now, this may suffice.
</p>
</div>
</div>
</div>

<div id="outline-container-orgd98042b" class="outline-2">
<h2 id="orgd98042b"><span class="section-number-2">3.</span> Language S:  first-order logic</h2>
<div class="outline-text-2" id="text-3">
<p>
Language S adds the following constructs to language XS:
</p>
<ul class="org-ul">
<li>universal and existential quantification</li>
<li>constants and variables denoting individuals rather than propositions</li>
</ul>
</div>

<div id="outline-container-orgb687815" class="outline-3">
<h3 id="orgb687815"><span class="section-number-3">3.1.</span> Note on different uses of identifiers</h3>
<div class="outline-text-3" id="text-3-1">
<p>
At thyis point, several classes of names must be distinguished:
</p>
<ul class="org-ul">
<li>variables ranging over propositions</li>
<li>constants denoting specific propositions</li>
<li>variables ranging over individuals</li>
<li>constants denoting specific individuals</li>
<li>predicate names (always constants)</li>
<li>functors (always constants; not present in language S,
but added in M)</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Propositions</th>
<th scope="col" class="org-left">Individuals</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">no arguments</td>
<td class="org-left">Propositional</td>
<td class="org-left">(Individual)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">variables</td>
<td class="org-left">variables</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">and constants</td>
<td class="org-left">and constants</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><i>n</i>-ary</td>
<td class="org-left">Predicate</td>
<td class="org-left">Functors</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">names</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
In some usages, syntactic distinctions are made for these classes of
names (lower- vs upper-case, regions of the alphabet, Latin vs Greek
letters), but in those usages identifiers are typically also limited
to single characters and empirically the identifiers seldom have much
mnemonic value.  Here, the distinctions are made as follows:
</p>
<ul class="org-ul">
<li>Expressions denoting individuals and those denoting propositions are
distinguished by context: an entire formula expresses a proposition,
while an argument to a predicate or functor denotes an individual.</li>
<li>For expressions with arguments, the functor or predicate name is
always taken to be a constant: allowing variables would make it a
higher-order logic.</li>
<li>In expressions without arguments, the distinction between variables
and constants is made as above in XS: variables are unmarked,
constants marked.</li>
</ul>

<p>
<i>(TBD:  eliminate propositional variables and constants?)</i>
</p>
</div>
</div>

<div id="outline-container-orgcedf164" class="outline-3">
<h3 id="orgcedf164"><span class="section-number-3">3.2.</span> Variables and constants</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The definitions of <i>prop-var</i> and <i>prop-constant</i> from XS
can be re-used without change.
</p>

<p>
In addition, we will need variables and constants for
individuals; they will have the same syntax.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ S-Atomics:  terms for individuals }
var = @name.
constant = quoted-name; numeral.
@numeral &gt; name = digit+.
</pre>
</div>
</div>
</div>

<div id="outline-container-orgcb42580" class="outline-3">
<h3 id="orgcb42580"><span class="section-number-3">3.3.</span> Predicates</h3>
<div class="outline-text-3" id="text-3-3">
<p>
In language S, propositions can take the form of a predicate
symbol followed by a parenthesized list of arguments separated
by commas (and whitespace).  Arguments are variables or constants
denoting individuals.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ Predicates }
predicate = @name, -"(", os, arg**comma, os, -")".
-arg = var; constant.
-comma = os, -",", os.
</pre>
</div>

<p>
Note:
</p>
<ul class="org-ul">
<li>No whitespace is allowed between the predicate name and the opening
parenthesis for the list of arguments.</li>
<li>The argument list must be surrounded by round parentheses; square
brackets or other forms of brackets are not accepted.</li>
</ul>
</div>
</div>

<div id="outline-container-orgd02453d" class="outline-3">
<h3 id="orgd02453d"><span class="section-number-3">3.4.</span> Quantification</h3>
<div class="outline-text-3" id="text-3-4">
<p>
If <i>F</i> is a formula, then <i>F</i> preceded by a universal or existential
quantifier is a formula.  This is a universal or existential
quantification symbol (<i>FORALL</i> or <i>THERE-EXIST</i>) followed by one or
more variables, the entire quantifier enclosed in (round) parentheses.
For universal quantification over a single variable, the operator can
be omitted (so "<code>(x)</code>" is allowed as an alternate for "<code>(all x)</code>").
Whitespace is optional after symbols, required after operators spelled
out with letters.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ Quantified formulas }
all = universal-quantifier, bracketed-formula.
exist = existential-quantifier, bracketed-formula.

-universal-quantifier = 
        -"(", os, FORALL-sym, os, vars, os, -")"
      | -"(", os, FORALL-lex, RS, vars, os, -")"
      | -"(", os, one-var, os, -")"
      .
-existential-quantifier = 
        -"(", os, EXIST-sym, os, vars, os, -")"
      | -"(", os, EXIST-lex, RS, vars, os, -")"
      .
@vars = var ++ comma-space.
@one-var &gt; vars = var.
-comma-space = os, -",", os, +" ".
</pre>
</div>

<p>
As for the logical operators, we allow fairly wide variation in
the spelling of the quantification symbols.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ Operators for quantifiers }
@FORALL-lex &gt; op = "all" | "ALL"
      | "for", os, "all" | "FOR", os, "ALL"
      | "A"
      .
@FORALL-sym &gt; op = "∀" { #2200 for all }
      .
@EXIST-lex &gt; op = "exists" | "EXISTS"
      | "exist" | "EXIST"
      | "some" | "SOME"
      | "E"
      .
@EXIST-sym &gt; op = "∃" { #2203 there exists }
      .
</pre>
</div>
</div>
</div>

<div id="outline-container-orgee67e78" class="outline-3">
<h3 id="orgee67e78"><span class="section-number-3">3.5.</span> Formulas</h3>
<div class="outline-text-3" id="text-3-5">
<p>
In language S, the set of basic formulas grows to include
predicates.  Since quantified formulas require bracketing,
they are defined as bracketed formulas.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ S: Basic formulas }
-basic-formula = 
        prop-var 
      | prop-constant 
      | predicate
      | bracketed-formula
      .
-bracketed-formula =  
        -"(", os, -formula, os, -")"
      | -"[", os, -formula, os, -"]"
      | all 
      | exist
      .
</pre>
</div>

<p>
The set of all formulas grows to include quantified formulas.
(<i>Actually, this is now the same as XS, since quantification
was introduced elsewhere.</i>)
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ S: Formulas in general }
formula = basic-formula | compound-formula.
-compound-formula = 
        not 
      | and | or 
      | implies | iff
      .
</pre>
</div>
</div>
</div>

<div id="outline-container-org756d594" class="outline-3">
<h3 id="org756d594"><span class="section-number-3">3.6.</span> Recapitulation of language S</h3>
<div class="outline-text-3" id="text-3-6">
<p>
The grammar of language S can be summarized:
</p>
<div class="org-src-container">
<pre class="src src-ixml">ixml version "1.1".

{ s.ixml:  grammar for first-order logic
  (without identity or functions) }
s-formulas = os, formula++NL, os.
&lt;&lt;S-Formulas&gt;&gt;
&lt;&lt;XS-Compound-formulas&gt;&gt;
&lt;&lt;Quantification&gt;&gt;
&lt;&lt;S-Basic-formulas&gt;&gt;

&lt;&lt;Predicates&gt;&gt;
&lt;&lt;XS-Atomics&gt;&gt;
&lt;&lt;S-Atomics&gt;&gt;
&lt;&lt;Quoted-strings&gt;&gt;

&lt;&lt;Logical-operators&gt;&gt;
&lt;&lt;Quantifier-ops&gt;&gt;

&lt;&lt;Basics&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf63b67b" class="outline-3">
<h3 id="orgf63b67b"><span class="section-number-3">3.7.</span> Tests for language S</h3>
<div class="outline-text-3" id="text-3-7">
<p>
All tests for language XS can also serve as tests for language S.
So the tests below focus on the new parts of XS.
</p>

<p>
Let's show some simple predicates.
</p>
<div class="org-src-container">
<pre class="src src-data">/* Predicates */
P(x)
Q(x, y, z)
born('Frege', 1848)
born('Frege', ‹anno-1848›)
born(`Frege', ١٨٤٨)
p()
Φ(x) /\ Δ(υ, ζ)
</pre>
</div>

<p>
No whitespace before the parenthesis:
</p>
<div class="org-src-container">
<pre class="src src-data">P (x)
</pre>
</div>

<p>
Double-quoted constants denote propositions, not individuals.  So
<code>logician("Frege")</code> is not grammatical.
</p>
<div class="org-src-container">
<pre class="src src-data">logician("Frege")
</pre>
</div>

<p>
Single quoting is not required (and not allowed) for numerals:
</p>
<div class="org-src-container">
<pre class="src src-data">born('Frege', ‹1848›)
</pre>
</div>

<p>
Quantification is, of course, the main thing:
</p>
<div class="org-src-container">
<pre class="src src-data">(all p)(philosopher(p) implies (some d)(born(p, d)))
(∀ p)(philosopher(p) ⇒ (∃ d)(born(p, d)))
(forall n)(natural(n) implies (exists m)(next(n, m)))
(A n)(natural(n) implies (E m)(next(n, m)))
(~(ALL x)[P(x)]) → (EXISTS x)(~P(x))
</pre>
</div>

<p>
Summing it up:
</p>
<div class="org-src-container">
<pre class="src src-data">&lt;&lt;XS-Tests-predicates&gt;&gt;

&lt;&lt;XS-Tests-quantification&gt;&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org8d45f17" class="outline-2">
<h2 id="org8d45f17"><span class="section-number-2">4.</span> Language M:  first-order logic with identity and functions</h2>
<div class="outline-text-2" id="text-4">
<p>
Vis-a-vis language S, language M adds:
</p>
<ul class="org-ul">
<li>identity and the symbol "<code>=</code>"</li>
<li>functions</li>
</ul>

<p>
Since the function syntax always uses parentheses, and functors are
always constants, language M extends the mechanisms for referring to
an individual: a specific individual can be referred to either by
using a constant like "<code>'f'</code>" or "<code>‹f›</code>" or by using a zero-argument
function expression like "<code>f()</code>".
</p>

<p>
[Full definition to be supplied.]
</p>
</div>
</div>

<div id="outline-container-orgf2e4ec6" class="outline-2">
<h2 id="orgf2e4ec6"><span class="section-number-2">5.</span> Language L:  additional convenience features</h2>
<div class="outline-text-2" id="text-5">
<p>
Language L adds a number of convenience features to language M:
</p>
<ul class="org-ul">
<li>typed quantifications (for all <i>x</i> of type <i>T</i>, &#x2026;; there is
some <i>x</i> of type <i>T</i> such that &#x2026;)</li>
<li>unique existential quantification (there exists exactly one
individual such that &#x2026;)</li>
<li>Skolem expressions (the unique individual who &#x2026;)</li>
<li>negated existential quantification (there is no <i>x</i> such that &#x2026;)</li>
<li><i>lone</i> existential quantification (there is at most one <i>x</i> such
that &#x2026;)</li>
</ul>

<p>
These are all intended as idioms for concise expression of commonly
used patterns; for each new construct, we specify a standard
translation into language M.
</p>

<p>
[Full definition to be supplied.]
</p>
</div>
</div>

<div id="outline-container-org4d7edb8" class="outline-2">
<h2 id="org4d7edb8"><span class="section-number-2">6.</span> Language XL: first-order logic plus set theory</h2>
<div class="outline-text-2" id="text-6">
<p>
Language XS adds sets <i>(and tuples? tbd)</i> to the universe of
discourse.  Concretely it adds:
</p>
<ul class="org-ul">
<li>the ability to declare variables as denoting sets of a given type</li>
<li>syntax for tuples</li>
<li>the ability to declare variables as denoting tuples in a given
relation (with symbols allowing the user to distinguish total
from partial functions, injections, and bijections)</li>
<li>symbols for standard set operations (membership, complementation,
union, intersection, subset relation, set difference)</li>
<li>set comprehensions</li>
</ul>

<p>
/(The inclusion of tuples, set comprehensions, and various forms of
functions and relations is uncertain.  Our initial instinct was to
exclude them for simplicity and reliability, since the ground has
proved so treacherous for so many.  But it may be that once sets are
added, we have tuples and relations whether we want them or not.  And
in that case, we might as well have set comprehensions to make them
easier to talk about.)/
</p>

<p>
[Full definition to be supplied.]
</p>
</div>
</div>

<div id="outline-container-org58d9e89" class="outline-2">
<h2 id="org58d9e89"><span class="section-number-2">7.</span> Concluding notes</h2>
<div class="outline-text-2" id="text-7">
<p>
The grammars defined here have two intended functions:
</p>
<ul class="org-ul">
<li>They provide specific targets for programs we write
which are to translate some notation or other into
'conventional first-order logic'.  That is, they allow
that vague description to be replaced by a statement
that the program's output is or should be sentences
in one of the languages defined here.</li>
<li>They make it easy to translate formulas into XML form
so they can be processed by XSLT or XQuery programs.  
We may write pretty-printers, normalizers, and (of course)
translations into specific target notations like ACL2
or TPTP FOF or TFF.</li>
</ul>
</div>

<div id="outline-container-org62112d1" class="outline-3">
<h3 id="org62112d1"><span class="section-number-3">7.1.</span> To do</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Watch this space.
</p>

<ul class="org-ul">
<li>Create minimal test case exhibiting <i>vars</i> problem, report.</li>
</ul>
</div>
</div>

<div id="outline-container-orga50b318" class="outline-3">
<h3 id="orga50b318"><span class="section-number-3">7.2.</span> Questions to consider</h3>
<div class="outline-text-3" id="text-7-2">
<p>
At the time this paper was last revised (May 2024 or later), several
questions seemed to merit further consideration.  They are not
strictly speaking open questions, in so far as the grammars given here
provide specific answers to them.  But they are questions in whose
answers the authors do not currently feel completely confident.  Those
we remembered to write down are:
</p>

<ul class="org-ul">
<li><p>
Q. Should subscripts be allowed in identifiers?
</p>

<p>
A. They already are.  The only effective way to allow subscripts is
to provide some convenient typographic shorthand for them; the
obvious choice is to separate the base name from the subscript with
an underscore: thus <i>x</i> with a subscribt of 1 can be written
<code>x\zwnj{}_1</code>, which can in HTML or on paper be formatted as <i>x<sub>1</sub></i>.
But this is already allowed.
</p>

<p>
Perhaps underscore should be allowed in identifiers <i>only</i> with the
meaning 'subscript'?  And thus only when followed by decimal digits?
</p>

<p>
Tentative answer:  unnecessary.
</p></li>

<li>Q. Include an explicit notation for tuples in language XL?</li>

<li>Q. Include explicit notation(s) for sequences in language XL?</li>

<li><p>
Q. Define variant grammars with less variation in the spelling of
operators?
</p>

<p>
Tentative answer: unnecessary.  Consistency of spelling is important
for presentation, but not for ingestion of formulas.  A normalizer
can easily be written to reserialize formula sequences in any
desired form with consistent spelling (and optionally
pretty-printing).
</p></li>

<li>Add <i>xor</i> (aka <i>aut</i>), <i>nand</i>, <i>nor</i>?</li>

<li>Eliminate propositional terms in S through XL / allow them only in
XS?</li>

<li>Allow marking variables with "<code>$</code>"?</li>

<li>Allow other forms of numbers as individual constants? (Currently
only unsigned integers are allowed.  And it's only the sentence
about Frege being born in 1848 that motivates that.)</li>
</ul>
</div>
</div>

<div id="outline-container-orgbd05d0c" class="outline-3">
<h3 id="orgbd05d0c"><span class="section-number-3">7.3.</span> Done</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Temporary list of to-do items now completed.
</p>
<ul class="org-ul">
<li>Split all operators into symbolic and alphabetic forms.
Adjacent space is optional for symbolic form, required
for alphabetics.  I think this works already for quantifiers,
but the current grammar allows <code>born('Frege', 1848)</code> to be
parsed either as intended or as equivalent to
<code>b ∨ n('Frege', 1848)</code>, which is going too far.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 16 May 2024</p>
<p class="author">Author: CMSMcQ and CH</p>
<p class="date">Created: 2024-05-23 Thu 16:49</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
