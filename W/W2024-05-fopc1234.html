<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2024-05-25 Sat 08:58 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Five varieties of first-order predicate calculus</title>
<meta name="author" content="CMSMcQ and CH" />
<meta name="generator" content="Org Mode" />
<style>
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 100,
                        linebreaks: { automatic: "false" },
                        webFont: "TeX"
                       },
        SVG: {scale: 100,
              linebreaks: { automatic: "false" },
              font: "TeX"},
        NativeMML: {scale: 100},
        TeX: { equationNumbers: {autoNumber: "AMS"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS_HTML"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Five varieties of first-order predicate calculus</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#orgef1c356">1. Design goals and design decisions</a></li>
<li><a href="#org2520b7a">2. Language XS:  sentential logic</a>
<ul>
<li><a href="#org05e4e9a">2.1. Basics: Names, whitespace, comments</a>
<ul>
<li><a href="#orgd462fec">2.1.1. Names</a></li>
<li><a href="#org8c4d570">2.1.2. Whitespace</a></li>
<li><a href="#org33712ea">2.1.3. Comments</a></li>
<li><a href="#orgd9e614b">2.1.4. Recapitulation (comments)</a></li>
</ul>
</li>
<li><a href="#org0a9df24">2.2. Propositional variables and constants</a></li>
<li><a href="#orgcb67701">2.3. Formulas</a></li>
<li><a href="#org64fc2df">2.4. Logical Operators</a></li>
<li><a href="#org73848f1">2.5. Recapitulation</a></li>
<li><a href="#org1859eb0">2.6. Tests</a></li>
</ul>
</li>
<li><a href="#orgca3bf55">3. Language S:  first-order logic</a>
<ul>
<li><a href="#org2d16c84">3.1. Note on different uses of identifiers</a></li>
<li><a href="#org9126b33">3.2. Variables and constants</a></li>
<li><a href="#org0831ed0">3.3. Predicates</a></li>
<li><a href="#orgbfd7e55">3.4. Quantification</a></li>
<li><a href="#orge1f7377">3.5. Formulas</a></li>
<li><a href="#org25c6a2a">3.6. Recapitulation of language S</a></li>
<li><a href="#org906cbfc">3.7. Tests for language S</a></li>
</ul>
</li>
<li><a href="#orgef6725c">4. Language M:  first-order logic with identity and functions</a>
<ul>
<li><a href="#org5e6ac51">4.1. Identities</a></li>
<li><a href="#org8fa3683">4.2. Functions</a></li>
<li><a href="#org014915d">4.3. Recapitulation of language M</a></li>
<li><a href="#orgf8fe928">4.4. Tests for language M</a></li>
</ul>
</li>
<li><a href="#orgc8235aa">5. Language L:  additional convenience features</a>
<ul>
<li><a href="#orgc64de05">5.1. New forms of quantification</a>
<ul>
<li><a href="#orga339ae3">5.1.1. Typed quantification</a></li>
<li><a href="#org089844d">5.1.2. Unique existential quantification</a></li>
<li><a href="#orgc554a06">5.1.3. Negated existential quantification</a></li>
<li><a href="#orge9fb1f6">5.1.4. Lone existential quantification</a></li>
</ul>
</li>
<li><a href="#org1e1c558">5.2. Definite descriptions / Skolem expressions</a></li>
<li><a href="#org7b1e93b">5.3. Recapitulation of language L</a></li>
<li><a href="#orgdc402e3">5.4. Test cases for language L</a></li>
</ul>
</li>
<li><a href="#org38f5460">6. Language XL: first-order logic plus set theory</a></li>
<li><a href="#org34b7a1b">7. Concluding notes</a>
<ul>
<li><a href="#orgdf36ef9">7.1. To do</a></li>
<li><a href="#org46278df">7.2. Questions to consider</a></li>
<li><a href="#orgb0149e6">7.3. Done</a></li>
</ul>
</li>
</ul>
</div>
</div>
<p>
This document describes several languages for the expression of
logical formulas, each containing the preceding.  For convenient
reference, the languages are given names chosen to suggest their
relative sizes:
</p>

<ul class="org-ul">
<li><b>XS</b> (extra-small), the first language, is for sentential logic.</li>
<li><b>S</b> (small) is for first-order logic without identity.</li>
<li><b>M</b> (medium) is for first-order logic with functions and identity.
We believe but have not undertaken to prove that M is equivalent to
the TPTP language of first-order formulas, FOF.</li>
<li><b>L</b> (large) adds some convenience features: typed quantification,
unique existential quantification, and skolem functions.  It is at
least roughly comparable to the TFF (typed first-order formulas)
language of TPTP.</li>
<li><b>XL</b> (extra-large) adds sets and set operations.  <i>Open question:
add tuples?</i></li>
</ul>

<div id="outline-container-orgef1c356" class="outline-2">
<h2 id="orgef1c356"><span class="section-number-2">1.</span> Design goals and design decisions</h2>
<div class="outline-text-2" id="text-1">
<p>
One goal of the paper is to provide a more precise description of the
target language(s) for our work translating Alloy models into
first-order logic.
</p>

<p>
A secondary goal is to provide a convenient syntax for presentation
and discussion of formulas that is as far as possible agnostic on the
particular symbols used for quantification and logical operators.
Textbooks on logic are notoriously divergent in their choices of
symbols, and so are those who publish papers containing logical
formulas.  Software for dealing with formulas is equally various in
its choices.  We see no reason to insist that logical conjunction be
expressed with "&amp;" but not with "/\" or "∧" or even just "and", and so
on.
</p>

<p>
Because different people seem to have different intuitions about which
logical operators should bind more tightly and which less tightly, we
do not attempt an elaborate set of operator priorities.  We allow (A
and (B and C)) to be writte (A and B and C), and similarly for (A or
(B or C)), but otherwise all nested compound expressions must be
parenthesized.  (This is a change from the grammar we worked on in
2021 and 2022.)
</p>

<p>
To avoid possible confusion over the scope of quantifiers, the same
rule applies to quantifications: we can write ∃x P(x), or (∃x)P(x),
but if the quantifier's scope includes an operator, parentheses are
needed:  ∃x (P(x) ∧ Q(x)).
</p>

<p>
We assume that for applications of logic to a domain (what Quine calls
post-foundational systems), it is important for identifiers to be
mnemonic, and (thus) that identifiers will often be longer than one
character.  
</p>
</div>
</div>

<div id="outline-container-org2520b7a" class="outline-2">
<h2 id="org2520b7a"><span class="section-number-2">2.</span> Language XS:  sentential logic</h2>
<div class="outline-text-2" id="text-2">
<p>
Language XS is for sentential logic.
</p>
</div>

<div id="outline-container-org05e4e9a" class="outline-3">
<h3 id="org05e4e9a"><span class="section-number-3">2.1.</span> Basics: Names, whitespace, comments</h3>
<div class="outline-text-3" id="text-2-1">
<p>
The basic symbols of the language are Unicode characters.
</p>
</div>

<div id="outline-container-orgd462fec" class="outline-4">
<h4 id="orgd462fec"><span class="section-number-4">2.1.1.</span> Names</h4>
<div class="outline-text-4" id="text-2-1-1">
<p>
A name is a sequence of characters beginning with a letter and containing
only letters, numeric digits, hyphens, and underscores.
</p>
<div class="org-src-container">
<pre class="src src-ixml" id="org82da722">name = letter, namechar*.
-letter = [L].
-namechar = letter; digit; ["-_"].
-digit = [Nd].
</pre>
</div>

<p>
Example names:
</p>
<pre class="example" id="org975bab0">
p
q
Prop-2a
φ
</pre>
</div>
</div>

<div id="outline-container-org8c4d570" class="outline-4">
<h4 id="org8c4d570"><span class="section-number-4">2.1.2.</span> Whitespace</h4>
<div class="outline-text-4" id="text-2-1-2">
<p>
Whitespace is any member of Unicode class Zs (Separator, space), as
well as a few control characters.  Required space is one or more
whitespace characters or comments; optional space is zero or more.
</p>
<div class="org-src-container">
<pre class="src src-ixml" id="orgbbaa065">-whitespace = -[Zs; #9; #A; #D].
-RS = (whitespace; comment)+.
-os = (whitespace; comment)*.
{ NL for required line breaks }
-NL = (-[Zs; #9] | comment)*, #A, os.
</pre>
</div>
</div>
</div>

<div id="outline-container-org33712ea" class="outline-4">
<h4 id="org33712ea"><span class="section-number-4">2.1.3.</span> Comments</h4>
<div class="outline-text-4" id="text-2-1-3">
<p>
A comment is a string of characters beginning with "&zwnj;/&zwnj;*"
(slash + asterisk) and ending with "&zwnj;*&zwnj;/" (asterisk + slash).
Comments may contain other comments, but not unmatched occurrences of
those delimiter strings.  Experience shows that this can easily be
formulated wrong, so we will start with a step-by-step development.
Within the comment, we can be in any of several states:
</p>
<ul class="org-ul">
<li><b>default</b>: the default state: nothing special has happened &#x2013; in
particular, we have not seen a star or a slash.  In this state,
several things can happen:
<ul class="org-ul">
<li>The empty string is acceptable (i.e. this can be the last state
of the comment data.)</li>
<li>A character other than slash or asterisk returns us to this state.</li>
<li>A nested comment returns us to this state.</li>
<li>A slash that does not start a nested comment takes us to state
<b>slash-seen</b>.</li>
<li>An asterisk not followed by a slash takes us to state <b>star-seen</b>.</li>
</ul></li>
<li><b>star-seen</b>:  we have seen an asterisk, and must not see a slash
next.  (If a slash is next, this is the wrong state.)
<ul class="org-ul">
<li>The empty string is acceptable (i.e. this can be the last state
of the comment data).</li>
<li>An asterisk that is not part of the comment-closing delimiter
returns us to this state.</li>
<li>Any character other than a slash or an asteriak returns us to
the <b>default</b> state.</li>
</ul></li>
<li><b>slash-seen</b>:  we have seen a slash, and must not now see an asterisk.
(If an asterisk is next, this is the wrong state.)
<ul class="org-ul">
<li>The empty string is not acceptable; this must <i>not</i> be the last
state of the comment data (since the closing delimiter starts
with the asterisk, which we must not see).</li>
<li>A nested comment returns us to the <b>default</b> state.</li>
<li>A slash that does not start a comment returns us to this state.</li>
<li>Any character other than a slash or star returns us to the
<b>default</b> state.</li>
</ul></li>
</ul>

<p>
We can describe this with a pseudo-regular grammar for <i>comment-data</i>.
(Why "pseudo-regular"?  like a regular grammar, it has rules whose
right-hand sides have a single symbol followed by a non-terminal
naming the next state, but it is not truly regular because <i>comment</i>
is not a terminal symbol; it's just treated as if it were one.)
</p>

<div class="org-src-container">
<pre class="src src-ixml">      comment = "/*", comment-data, "*/".
 comment-data = default-state.
default-state = ()
              | ~["/*"], default-state
              | comment, default-state
              | "/", slash-seen
              | "*", star-seen
              .
    star-seen = ()
              | "*", star-seen
              | ~["/*"], default-state
              .
   slash-seen = comment, default-state
              | "/", slash-seen
              | ~["/*"], default-state
              .
</pre>
</div>

<p>
The rules for <i>star-seen</i> and <i>slash-seen</i> can be simplified by
applying Arden's Lemma. (<i>A = X, A; B.</i> can be rewritten <i>A = X*, B.</i>)
</p>
<div class="org-src-container">
<pre class="src src-ixml">default-state = ()
              | ~["/*"], default-state
              | comment, default-state
              | "/", slash-seen
              | "*", star-seen
              .          
   star-seen = "*"*, (~["/*"], default-state)?.
  slash-seen = "/"*, (comment | ~["/*"]), default-state.
</pre>
</div>

<p>
Now the references to <i>star-seen</i> and <i>slash-seen</i> can be expanded
in place.  We then replace the right-hand side beginning with "*" 
with two simpler right-hand sides.
</p>
<div class="org-src-container">
<pre class="src src-ixml">default-state = ()
              | ~["/*"], default-state
              | comment, default-state
              | "/", "/"*, (comment | ~["/*"]), default-state
              | "*", "*"*, ~["/*"], default-state
              | "*", "*"*
              .          
</pre>
</div>

<p>
Further simplification produces:
</p>
<div class="org-src-container">
<pre class="src src-ixml">default-state = "/"*, (comment | ~["/*"]), default-state
              | "*"+, ~["/*"], default-state
              | "*"*
              .          
</pre>
</div>

<p>
We can now apply Arden's Lemma to <i>default-state</i> to
produce a single rule for comment data.
</p>
<div class="org-src-container">
<pre class="src src-ixml">default-state = ("*"+, ~["/*"] | "/"*, (comment | ~["/*"]))*, "*"*.          
</pre>
</div>

<p>
With that development providing some confidence in the
rule, we can write the comment rules for real now:
</p>
<div class="org-src-container">
<pre class="src src-ixml" id="org02f6370">      comment = -"/*", comment-data, -"*/".
-comment-data = ("*"+, ~["/*"] 
                | "/"*, (comment | ~["/*"]))*, 
                "*"*.
</pre>
</div>

<p>
This is complicated enough that it may be worth writing down
some positive and negative test cases.  Positive examples include:
</p>
<div class="org-src-container">
<pre class="src src-data">/**/
/* */
/* this is a comment */
/* *this* example/test case contains nested stars and a slash (/) */
/*/* a nested comment*/ and more*/
/*/* a nested comment*/*** and ////* another */*/
/*******/
/*//////* test */  ***/
</pre>
</div>

<p>
Negative examples:
(1) An asterisk followed by a slash.
</p>
<div class="org-src-container">
<pre class="src src-data">/* A slash (*/*) cannot be emphasized here. */
</pre>
</div>
<p>
(2) Comment data ending with a slash.
</p>
<div class="org-src-container">
<pre class="src src-data">/*///*/
</pre>
</div>

<p>
An ad-hoc test grammar will allow us to run these test cases:
</p>
<div class="org-src-container">
<pre class="src src-ixml">tests = (whitespace; comment)*.
&lt;&lt;Comments&gt;&gt;
&lt;&lt;Whitespace&gt;&gt;
</pre>
</div>

<p>
These tests can be run manually in a shell:
</p>
<pre class="example" id="org426f7e8">
for f in comments-*.txt ; \
    do markup-blitz.sh $f comment-tests.ixml ${f%.txt}.xml; \
    done
</pre>
<p>
I have no automatic checking of results:  the positive
examples should produce XML results which look plausible,
and the negative examples should all fail to parse.  A quick
check can be done with
</p>
<pre class="example" id="org5398c3a">
grep ixml:state comments-*.xml
</pre>
</div>
</div>

<div id="outline-container-orgd9e614b" class="outline-4">
<h4 id="orgd9e614b"><span class="section-number-4">2.1.4.</span> Recapitulation (comments)</h4>
<div class="outline-text-4" id="text-2-1-4">
<p>
We can sum up these low-level rules thus:
</p>
<div class="org-src-container">
<pre class="src src-ixml" id="orgd9ca49a">
{ Basics:  names, whitespace, comments }
name = letter, namechar*.
-letter = [L].
-namechar = letter; digit; ["-_"].
-digit = [Nd].
-whitespace = -[Zs; #9; #A; #D].
-RS = (whitespace; comment)+.
-os = (whitespace; comment)*.
{ NL for required line breaks }
-NL = (-[Zs; #9] | comment)*, #A, os.
      comment = -"/*", comment-data, -"*/".
-comment-data = ("*"+, ~["/*"] 
                | "/"*, (comment | ~["/*"]))*, 
                "*"*.
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org0a9df24" class="outline-3">
<h3 id="org0a9df24"><span class="section-number-3">2.2.</span> Propositional variables and constants</h3>
<div class="outline-text-3" id="text-2-2">
<p>
A propositional variable is a name.
</p>

<p>
In language XS, a propositional constant is a name enclosed in single
quotes.  In practice, we'll use typewriter apostrophes, but to allow
formulas to be copy-pasted from contexts which use proper quotation
marks, typeset quotation marks are also allowed (<code>‘...’</code>, <code>‹...›</code>,
<code>›...‹</code>), as are (sigh) TeX-style single quotation marks (<code>`...'</code>).
We allow single guillemets in either order, because both
inward-pointing pairs and outward-pointing pairs are used.  (We have
seen claims that one is French practice and the other German practice,
but we believe we have seen both forms in German typesetting.)
</p>

<div class="org-src-container">
<pre class="src src-ixml" id="org61b7823">{ XS Atomics:  propositional variables and constants }
prop-var = @name.
prop-constant = quoted-name; quoted-string.
-quoted-name = -#27, @name, -#27 
               { #27 is typewriter apostrophe }
             | -#60, @name, -#27 
               { #60 is typewriter grave accent }
             | -#2018, @name, -#2019 
               { hi 6, hi 9 }
             | -#203A, @name, -#2039 
               { single guillemets pointing in }
             | -#2039, @name, -#203A 
               { single guillemets pointing out }
             .
</pre>
</div>

<p>
At this point, I am mildly tempted to allow arbitrary one-line strings
enclosed in double quotes, so as to make <code>"Socrates is a Greek."</code> and
<code>"All Greeks are mortal."</code> allowable as propositional constants.  And,
after all, why not?
</p>
<div class="org-src-container">
<pre class="src src-ixml" id="org9729350">@quoted-string
      &gt; string = -#22, (~[#22; #A]; (#22, #22))*, -#22
               | -#60, -#60, ~[#22; #60; #A]*, -#27, -#27 
               | -#60, -#60, ~[#22; #60; #A]*, -#22 
               | -#201C, ~[#201C; #201D; #A]*, -#201D
               | -#AB, ~[#AB; #BB; #A]*, -#BB
               | -#BB, ~[#AB; #BB; #A]*, -#AB
               .
</pre>
</div>
<p>
For the record:
</p>
<ul class="org-ul">
<li>#22 is a straight typewriter double quotation mark.</li>
<li>#60 is a grave accent, often used doubled for
a left double quotation mark by TeX users.</li>
<li>#201C and #201D are typeset double quotation marks
conventional in English-language typesetting
(high 66, high 99).</li>
<li>#AB and #BB are left- and right-pointing guillemets.
We allow them to be paired pointing in or pointing
out, because both styles may be encountered in
European typesetting.</li>
</ul>

<p>
In the first form of quoted string, a double quotation mark in the
string may be represented by two double quotation marks in a row.  We
have not bothered with similar escape mechanisms in the other forms.
</p>
</div>
</div>

<div id="outline-container-orgcb67701" class="outline-3">
<h3 id="orgcb67701"><span class="section-number-3">2.3.</span> Formulas</h3>
<div class="outline-text-3" id="text-2-3">
<p>
In language XS, a basic formula is a propositional variable, a propositional
constant, or a formula enclosed in parentheses.  We allow both round parentheses
and square brackets, to ease the reading of complex formulas.
</p>

<div class="org-src-container">
<pre class="src src-ixml">{ XS Basic formulas }
-basic-formula = prop-var | prop-constant | not
               | -"(", os, -formula, os, -")"
               | -"[", os, -formula, os, -"]".
</pre>
</div>

<p>
A <i>formula</i> in general is a basic formula or one of several kinds of
compound formulas.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ XS Formulas in general }
formula = basic-formula | compound-formula.
-compound-formula = and | or | implies | iff.
</pre>
</div>

<p>
Each logical operator defines a distinct type of compound formula.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ Compound formulas }
    not = NOT, basic-formula.
    and = (and | basic-formula), AND, basic-formula.
     or = (or  | basic-formula),  OR, basic-formula.
implies = basic-formula, IMPLIES, basic-formula.
    iff = basic-formula, IFF, basic-formula.
</pre>
</div>

<p>
We want <i>not</i>, <i>and</i>, and <i>or</i> all to allow multiple repetitions of
the operator without parentheses.  Since <i>and</i> and <i>or</i> are
associative, expressions like <i>A ∧ (B ∧ C)</i> and <i>(A ∧ B) ∧ C</i> always
have the same truth value, so there is no reason to require
parentheses to specify one structure or the other.
</p>

<p>
For conditionals and biconditionals, however, the left- and
right-associative interpretations of expressions like <i>A implies B
implies C</i> or <i>A iff B iff C</i> are not equivalent.  If there were a
principled, easily remembered rationale for choosing left or right
associativity, it would make sense to chose one or the other.  But we
see no such rationale.  To avoid confusion, we require parentheses
around nested occurrences of <i>implies</i> and <i>iff</i>.
</p>

<p>
For the <i>not</i> operator, there is only one imaginable structure, so the
parentheses in an expression like <i>¬(¬(¬p))</i> are optional.  Similarly,
the scope of a negation symbol is clear if it applies to the
right-most operand of an <i>n</i>-ary or binary operator.  So <i>not</i>
expressions are allowed in those positions.  As a result, the
parentheses are necessary in <code>(¬p)∨q</code> and <code>¬(p∨q)</code> &#x2013; the expression
<code>¬p∨q</code> is ungrammatical &#x2013; but no parentheses are needed in <code>p∨¬q</code>.
</p>

<p>
We might wish to consider adding other operators: <i>xor</i> (or <i>aut</i>),
<i>nor</i>, <i>nand</i>.  But since we do not want those operators in language
M, and we want M to be a proper superset of XS, we leave them out.
</p>

<p>
One minor technical point may be worth making: in general the grammar
tries to retain information about how the input spells the operators,
in case a downstream process wants to preserve those spellings in its
output.  But since we record the operators in an attribute (<i>@op</i>),
only one operator spelling can be recorded; this is why we use a
(left-)recursive structure for conjunction and disjunction, instead of
using the natural ixml formulation for <i>n</i>-ary operators, which would
be:
</p>
<div class="org-src-container">
<pre class="src src-ixml">not = NOT+, basic-formula.
and = basic-formula++(-AND), AND, basic-formula.
 or = basic-formula++(-OR),  OR,  basic-formula.
</pre>
</div>
</div>
</div>

<div id="outline-container-org64fc2df" class="outline-3">
<h3 id="org64fc2df"><span class="section-number-3">2.4.</span> Logical Operators</h3>
<div class="outline-text-3" id="text-2-4">
<p>
For each operator, we seek to allow a wide variety of different forms:
symbols used in logic textbooks, symbols and keywords used in systems
like Alloy or TLA+ or Z, symbols, keywords, and character sequences
used in combination programming language / theorem provers like ACL2,
Lean, and Agda.  <i>Not</i> included: operators for C.
</p>

<p>
For the record, a survey of some sources shows the following:
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Source</th>
<th scope="col" class="org-left">not</th>
<th scope="col" class="org-left">and</th>
<th scope="col" class="org-left">or</th>
<th scope="col" class="org-left">implies</th>
<th scope="col" class="org-left">iff</th>
<th scope="col" class="org-left">forall</th>
<th scope="col" class="org-left">exists</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">Jeffrey</td>
<td class="org-left">—</td>
<td class="org-left">&amp;</td>
<td class="org-left">∨</td>
<td class="org-left">→</td>
<td class="org-left">↔</td>
<td class="org-left">(x)</td>
<td class="org-left">(∃x)</td>
</tr>

<tr>
<td class="org-left">unnamed*</td>
<td class="org-left">~, ⁓</td>
<td class="org-left">·</td>
<td class="org-left">+</td>
<td class="org-left">⊃</td>
<td class="org-left">≡</td>
<td class="org-left">⋀x, Πx</td>
<td class="org-left">⋁x, Σx</td>
</tr>

<tr>
<td class="org-left">Quine 1941</td>
<td class="org-left">⁓, p̄</td>
<td class="org-left">·</td>
<td class="org-left">∨</td>
<td class="org-left">⊃</td>
<td class="org-left">≡</td>
<td class="org-left">(x)</td>
<td class="org-left">(∃x)</td>
</tr>

<tr>
<td class="org-left">Smullyan</td>
<td class="org-left">⁓</td>
<td class="org-left">∧</td>
<td class="org-left">∨</td>
<td class="org-left">⊃</td>
<td class="org-left">↔</td>
<td class="org-left">∀x</td>
<td class="org-left">∃x</td>
</tr>

<tr>
<td class="org-left">Quine 1950</td>
<td class="org-left">—, p̄</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">∨</td>
<td class="org-left">→</td>
<td class="org-left">↔</td>
<td class="org-left">∀x</td>
<td class="org-left">∃x</td>
</tr>

<tr>
<td class="org-left">Alloy</td>
<td class="org-left">not</td>
<td class="org-left">and</td>
<td class="org-left">or &zwnj;</td>
<td class="org-left">implies</td>
<td class="org-left">iff</td>
<td class="org-left">all x</td>
<td class="org-left">some x</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">!</td>
<td class="org-left">&amp;&amp;</td>
<td class="org-left">&vert;&vert; &zwnj;</td>
<td class="org-left">&zwnj;=&gt;</td>
<td class="org-left">&lt;=&gt;</td>
<td class="org-left">all x</td>
<td class="org-left">some x</td>
</tr>

<tr>
<td class="org-left">TLA+</td>
<td class="org-left">¬</td>
<td class="org-left">∧</td>
<td class="org-left">∨</td>
<td class="org-left">⇒</td>
<td class="org-left">≡</td>
<td class="org-left">∀x</td>
<td class="org-left">∃x</td>
</tr>

<tr>
<td class="org-left">TLA+ ASCII</td>
<td class="org-left">~</td>
<td class="org-left">/\</td>
<td class="org-left">\/</td>
<td class="org-left">﻿=&gt;</td>
<td class="org-left">&lt;=&gt;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">\lnot</td>
<td class="org-left">\&zwnj;land</td>
<td class="org-left">\&zwnj;lor</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">\&zwnj;equiv</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">\&zwnj;neg</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">Agda ASCII</td>
<td class="org-left">\&zwnj;lnot</td>
<td class="org-left">\&zwnj;and</td>
<td class="org-left">\&zwnj;or</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">\&zwnj;neg</td>
<td class="org-left">\&zwnj;wedge</td>
<td class="org-left">\&zwnj;vee</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
,* Notes:
</p>
<ul class="org-ul">
<li>The row labeled 'unnamed' is from Jeffrey's appendix on notation.</li>
<li>Quine 1941 is <i>Element logic</i>, revised edition.</li>
<li>Smullyan is <i>First-order logic</i>.</li>
<li>Quine 1950 is <i>Methods of logic</i>. Conjunction is expressed by
juxtaposition (and identifiers for propositions are in consequence
restricted to single characters).</li>
<li>Alloy also allows double bar (<code>||</code>) for disjunction.  It defines
the additional quantifiers <b>no</b>, <b>lone</b>, and <b>one</b>.</li>
<li>Agda presumably does have an implication symbol (and equivalence,
and so on), but I have not progressed far enough to know what it is.</li>
</ul>

<p>
Quine notes that swung dash (⁓) sometimes is used with the
meaning 'iff'.
</p>

<div class="org-src-container">
<pre class="src src-ixml">{ Logical operators }
@NOT &gt; op = NOT-sym, os
          | NOT-alpha, RS
          .
NOT-alpha = "not" | "NOT".
  NOT-sym = "¬" { #AC not sign }
          | "-"
          | "—" { #2014 em dash }
          | "~" { #7E tilde }
          | "⁓" { #2053 swung dash }
          . 

@AND &gt; op = os, AND-sym, os
          | RS, AND-alpha, RS
          .
AND-alpha = "and" | "AND"
          | "\land" | "\and" 
          | "\wedge"
          .
  AND-sym = "∧" { #2227 }
          | "&amp;"
          | "&amp;&amp;"
          | "/\" { emacs here wants a " }
          .

 @OR &gt; op = os, OR-sym, os
          | RS, OR-alpha, RS
          .
 OR-alpha = "or" | "OR" 
          | "vel" | "VEL" 
          | "\lor" | "\or" | "\vee"
          .
   OR-sym = "∨" { #2228 logical or }
          | "|" 
          | "||"
          | "\/"
          . 
@IMPLIES &gt; op = os, IMPLIES-sym, os
              | RS, IMPLIES-alpha, RS. 
IMPLIES-alpha = "implies" | "IMPLIES" 
              | "only", os, "if" 
              | "ONLY", os, "IF"
              .
  IMPLIES-sym = "⇒" { #21D2 right double arrow } 
              | "⊃" { #2283 superset of }
              | "→" { #2192 right arrow }
              | "-&gt;"
              | "=&gt;"
              .

@IFF &gt; op = os, IFF-sym, os
          | RS, IFF-alpha, RS.
IFF-alpha = "iff" | "IFF"; "\equiv".
  IFF-sym = "⇔" { #21D4 left right double arrow }
          | "↔" { #2194 left right arrow }
          | "≡" { #2261 identical to }
          | "&lt;-&gt;"
          | "&lt;=&gt;"
          .
</pre>
</div>
</div>
</div>
<div id="outline-container-org73848f1" class="outline-3">
<h3 id="org73848f1"><span class="section-number-3">2.5.</span> Recapitulation</h3>
<div class="outline-text-3" id="text-2-5">
<p>
The entire XS grammar can now be summarized:
</p>
<div class="org-src-container">
<pre class="src src-ixml">ixml version "1.1".

{ xs.ixml:  grammar for sentential logic }
xs-formulas = os, formula++NL, os.
&lt;&lt;XS-Formulas&gt;&gt;
&lt;&lt;XS-Compound-formulas&gt;&gt;
&lt;&lt;XS-Basic-formulas&gt;&gt;

&lt;&lt;XS-Atomics&gt;&gt;
&lt;&lt;Quoted-strings&gt;&gt;

&lt;&lt;Logical-operators&gt;&gt;

&lt;&lt;Basics&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org1859eb0" class="outline-3">
<h3 id="org1859eb0"><span class="section-number-3">2.6.</span> Tests</h3>
<div class="outline-text-3" id="text-2-6">
<p>
Some simple positive tests for language XS follow.
First, some propositional variables.
</p>
<div class="org-src-container">
<pre class="src src-data">/* Some basic formulas */
/* Propositional variables */
p
q
Prop-2a
φ
א
/* and */
</pre>
</div>
<p>
Note that the string "and" is a propositional
variable as well as a logical operator for
conjunction. Parsed as a formula, however, it
can only be the latter.  In the context "A and B"
or "p and q", it can only be the former.
(In the test context, it can be either, however,
so I commented it back out.)
</p>

<p>
Then, some propositional constants.
</p>
<div class="org-src-container">
<pre class="src src-data">/* Propositional constants */
'Prop-2a'
›Frege-was-born-in-1848‹
‹Russell-died-in-1970›
`Prop-2b'

/* Double-quoted strings as propositional constants */
"Frege was born in 1848"
``he is at his desk''
“he is eating lunch”
</pre>
</div>

<p>
Then, some propositional constants.
</p>
<div class="org-src-container">
<pre class="src src-data">/* Parenthesized basic formulas */
(q)
( Prop-2a )
[(φ)]
['Prop-2a' ]
</pre>
</div>

<p>
And now, finally, some compound formulas:
</p>
<div class="org-src-container">
<pre class="src src-data">/* Compound formulas */
(p iff (q&amp;r)) only if (p &amp;&amp; q)
(p implies (q &amp; r)) iff (p ∧ q)
(p ∨ q) implies r
p ∨ (q implies r)
p implies (q or r)
"Jones is here" and "Smith is away"
[([(p∨q) ∧ (p∨-q)] ∨ [(-p)∧q]) ⇔ q] ⇒ [(p∧r) ∨ (p∧~r)]
</pre>
</div>

<p>
Bringing all the positive examples together,
we have:
</p>
<div class="org-src-container">
<pre class="src src-data">&lt;&lt;XS-Tests-vars&gt;&gt;
&lt;&lt;XS-Tests-constants&gt;&gt;
&lt;&lt;XS-Tests-parens-basic&gt;&gt;
&lt;&lt;XS-Tests-compounds&gt;&gt;
</pre>
</div>
<p>
Some negative examples should be added.  But for
now, this may suffice.
</p>
</div>
</div>
</div>

<div id="outline-container-orgca3bf55" class="outline-2">
<h2 id="orgca3bf55"><span class="section-number-2">3.</span> Language S:  first-order logic</h2>
<div class="outline-text-2" id="text-3">
<p>
Language S adds the following constructs to language XS:
</p>
<ul class="org-ul">
<li>universal and existential quantification</li>
<li>constants and variables denoting individuals rather than propositions</li>
</ul>
</div>

<div id="outline-container-org2d16c84" class="outline-3">
<h3 id="org2d16c84"><span class="section-number-3">3.1.</span> Note on different uses of identifiers</h3>
<div class="outline-text-3" id="text-3-1">
<p>
At thyis point, several classes of names must be distinguished:
</p>
<ul class="org-ul">
<li>variables ranging over propositions</li>
<li>constants denoting specific propositions</li>
<li>variables ranging over individuals</li>
<li>constants denoting specific individuals</li>
<li>predicate names (always constants)</li>
<li>functors (always constants; not present in language S,
but added in M)</li>
</ul>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-left">Propositions</th>
<th scope="col" class="org-left">Individuals</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">no arguments</td>
<td class="org-left">Propositional</td>
<td class="org-left">(Individual)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">variables</td>
<td class="org-left">variables</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">and constants</td>
<td class="org-left">and constants</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left"><i>n</i>-ary</td>
<td class="org-left">Predicate</td>
<td class="org-left">Functors</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">names</td>
<td class="org-left">&#xa0;</td>
</tr>
</tbody>
</table>

<p>
In some usages, syntactic distinctions are made for these classes of
names (lower- vs upper-case, regions of the alphabet, Latin vs Greek
letters), but in those usages identifiers are typically also limited
to single characters and empirically the identifiers seldom have much
mnemonic value.  Here, the distinctions are made as follows:
</p>
<ul class="org-ul">
<li>Expressions denoting individuals and those denoting propositions are
distinguished by context: an entire formula expresses a proposition,
while an argument to a predicate or functor denotes an individual.</li>
<li>For expressions with arguments, the functor or predicate name is
always taken to be a constant: allowing variables would make it a
higher-order logic.</li>
<li>In expressions without arguments, the distinction between variables
and constants is made as above in XS: variables are unmarked,
constants marked.</li>
</ul>

<p>
<i>(TBD:  eliminate propositional variables and constants?)</i>
</p>
</div>
</div>

<div id="outline-container-org9126b33" class="outline-3">
<h3 id="org9126b33"><span class="section-number-3">3.2.</span> Variables and constants</h3>
<div class="outline-text-3" id="text-3-2">
<p>
The definitions of <i>prop-var</i> and <i>prop-constant</i> from XS
can be re-used without change.
</p>

<p>
In addition, we will need variables and constants for
individuals; they will have the same syntax.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ S-Atomics:  terms for individuals }
var = @name.
constant = quoted-name; numeral.
@numeral &gt; name = digit+.
</pre>
</div>
<p>
In language S, we define a <i>term</i> as a variable or
a constant.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ S-Terms:  terms for individuals }
-term = var; constant.
</pre>
</div>
</div>
</div>

<div id="outline-container-org0831ed0" class="outline-3">
<h3 id="org0831ed0"><span class="section-number-3">3.3.</span> Predicates</h3>
<div class="outline-text-3" id="text-3-3">
<p>
In language S, propositions can take the form of a predicate
symbol followed by a parenthesized list of arguments separated
by commas (and whitespace).  Arguments are variables or constants
denoting individuals.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ Predicates }
predicate = @name, -"(", os, arg**comma, os, -")".
-arg = term.
-comma = os, -",", os.
</pre>
</div>

<p>
Note:
</p>
<ul class="org-ul">
<li>No whitespace is allowed between the predicate name and the opening
parenthesis for the list of arguments.</li>
<li>The argument list must be surrounded by round parentheses; square
brackets or other forms of brackets are not accepted.</li>
<li>The argument list may be empty.</li>
<li>Predicates with no arguments may be thus be written either with an
empty argument list (i.e. in the form "<code>p()</code>") or with no argument
list at all ("<code>p</code>").  The grammar currently renders these
differently: the form "<code>p</code>" is parsed as a propositional variable
(<i>prop-var</i>); the form "<code>p()</code>" is parsed as a <i>predicate</i> named "p"
with no arguments.</li>
</ul>
</div>
</div>

<div id="outline-container-orgbfd7e55" class="outline-3">
<h3 id="orgbfd7e55"><span class="section-number-3">3.4.</span> Quantification</h3>
<div class="outline-text-3" id="text-3-4">
<p>
If <i>F</i> is a formula, then <i>F</i> preceded by a universal or existential
quantifier is a formula.  This is a universal or existential
quantification symbol (<i>FORALL</i> or <i>THERE-EXIST</i>) followed by one or
more variables, the entire quantifier enclosed in (round) parentheses.
For universal quantification over a single variable, the operator can
be omitted (so "<code>(x)</code>" is allowed as an alternate for "<code>(all x)</code>").
Whitespace is optional after symbols, required after operators spelled
out with letters.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ Quantified formulas }
-quantified-formula = all | exist.
all = universal-quantifier, os, bracketed-formula.
exist = existential-quantifier, os, bracketed-formula.

-universal-quantifier = 
        -"(", os, FORALL-sym, os, vars, os, -")"
      | -"(", os, FORALL-lex, RS, vars, os, -")"
      | -"(", os, one-var, os, -")"
      .
-existential-quantifier = 
        -"(", os, EXIST-sym, os, vars, os, -")"
      | -"(", os, EXIST-lex, RS, vars, os, -")"
      .
@vars = var ++ comma-space.
@one-var &gt; vars = var.
-comma-space = os, -",", os, +" ".
</pre>
</div>

<p>
As for the logical operators, we allow fairly wide variation in
the spelling of the quantification symbols.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ Operators for quantifiers }
@FORALL-lex &gt; op = "all" | "ALL"
      | "for", os, "all" | "FOR", os, "ALL"
      | "A"
      .
@FORALL-sym &gt; op = "∀" { #2200 for all }
      .
@EXIST-lex &gt; op = "exists" | "EXISTS"
      | "exist" | "EXIST"
      | "some" | "SOME"
      | "E"
      .
@EXIST-sym &gt; op = "∃" { #2203 there exists }
      .
</pre>
</div>
</div>
</div>

<div id="outline-container-orge1f7377" class="outline-3">
<h3 id="orge1f7377"><span class="section-number-3">3.5.</span> Formulas</h3>
<div class="outline-text-3" id="text-3-5">
<p>
In language S, the set of basic formulas grows to include predicates.
And we give a separate name to bracketed formulas.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ S: Basic formulas }
-basic-formula = 
        prop-var 
      | prop-constant 
      | predicate
      | not
      | bracketed-formula
      .
</pre>
</div>
<p>
Since quantified formulas require bracketing, they are defined as
bracketed formulas.
</p>
<div class="org-src-container">
<pre class="src src-ixml">-bracketed-formula =  
        -"(", os, -formula, os, -")"
      | -"[", os, -formula, os, -"]"
      | quantified-formula
      .
</pre>
</div>

<p>
The set of all formulas grows to include quantified formulas.
(<i>Actually, this is now the same as XS, since quantification
was introduced elsewhere.</i>)
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ S: Formulas in general }
formula = basic-formula | compound-formula.
-compound-formula = and | or | implies | iff.
</pre>
</div>
</div>
</div>

<div id="outline-container-org25c6a2a" class="outline-3">
<h3 id="org25c6a2a"><span class="section-number-3">3.6.</span> Recapitulation of language S</h3>
<div class="outline-text-3" id="text-3-6">
<p>
The grammar of language S can be summarized:
</p>
<div class="org-src-container">
<pre class="src src-ixml">ixml version "1.1".

{ s.ixml:  grammar for first-order logic
  (without identity or functions) }
s-formulas = os, formula++NL, os.
&lt;&lt;S-Formulas&gt;&gt;
&lt;&lt;XS-Compound-formulas&gt;&gt;
&lt;&lt;Quantification&gt;&gt;
&lt;&lt;S-Basic-formulas&gt;&gt;
&lt;&lt;Bracketed-formulas&gt;&gt;

&lt;&lt;Predicates&gt;&gt;
&lt;&lt;XS-Atomics&gt;&gt;
&lt;&lt;S-Terms&gt;&gt;
&lt;&lt;S-Atomics&gt;&gt;
&lt;&lt;Quoted-strings&gt;&gt;

&lt;&lt;Logical-operators&gt;&gt;
&lt;&lt;Quantifier-ops&gt;&gt;

&lt;&lt;Basics&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-org906cbfc" class="outline-3">
<h3 id="org906cbfc"><span class="section-number-3">3.7.</span> Tests for language S</h3>
<div class="outline-text-3" id="text-3-7">
<p>
All tests for language XS can also serve as tests for language S.
So the tests below focus on the new parts of XS.
</p>

<p>
Let's show some simple predicates.
</p>
<div class="org-src-container">
<pre class="src src-data">/* Predicates */
P(x)
Q(x, y, z)
born('Frege', 1848)
born('Frege', ‹anno-1848›)
born(`Frege', ١٨٤٨)
p()
Φ(x) /\ Δ(υ, ζ)
</pre>
</div>

<p>
No whitespace before the parenthesis:
</p>
<div class="org-src-container">
<pre class="src src-data">P (x)
</pre>
</div>

<p>
Double-quoted constants denote propositions, not individuals.  So
<code>logician("Frege")</code> is not grammatical.
</p>
<div class="org-src-container">
<pre class="src src-data">logician("Frege")
</pre>
</div>

<p>
Single quoting is not required (and not allowed) for numerals:
</p>
<div class="org-src-container">
<pre class="src src-data">born('Frege', ‹1848›)
</pre>
</div>

<p>
Quantification is, of course, the main thing:
</p>
<div class="org-src-container">
<pre class="src src-data">(all p)(philosopher(p) implies (some d)(born(p, d)))
(∀ p)(philosopher(p) ⇒ (∃ d)(born(p, d)))
(forall n)(natural(n) implies (exists m)(next(n, m)))
(A n)(natural(n) implies (E m)(next(n, m)))
(~(ALL x)[P(x)]) → (EXISTS x)(~P(x))
</pre>
</div>

<p>
And we need to test at least some quantifications
with multiple variables.
</p>
<div class="org-src-container">
<pre class="src src-data">/* Some examples from Smullyan */
(ψ ⇒ (∀x)(φ(x))) ≡ (∀y)[ψ ⇒ (φ(y))]
(psi implies (x)(phi(x))) iff (all y)[psi only if (phi(y))]
/* R symmetric: */
(A x)(A y)[R(x,y) implies R(y,x)] 
(FORALL x, y)[R(x,y) implies R(y,x)] 
/* R transitive: */
(x)(y)(z)[(R(x,y) &amp; R(y,z)) implies R(x,z)] 
(all x, y, z)[(R(x,y) &amp; R(y,z)) implies R(x,z)] 
/* R reflexive */
(∀ x, y)(R(x, y) ⇒ R(x, x))

/* Some examples from Quine */
(all y)(some x)((F(y,y) and F(y, x)) or F(x, y))

(all w)(all x)(-[F(x,y) &amp; F(x,w) &amp; F(w,x)])
(ALL w, x)(-[F(x,y) &amp; F(x,w) &amp; F(w,x)])
(E x)(A w)[(-F(x,y)) &amp; ([~F(x,w)] vel not F(w,x) )]
</pre>
</div>
<p>
Note that for the last formula, my initial formulation
was "<code>(E x)(A w)[-F(x,y) &amp; (~F(x,w) vel not F(w,x) )]</code>",
which suggests I find it natural to assume a tighter
binding for negation than for conjunction.  The same
thing happened on at least one earlier test case; it
suggests we should contemplate making negation bind
more tightly than the binary operators.
</p>

<p>
Summing it up:
</p>
<div class="org-src-container">
<pre class="src src-data">&lt;&lt;XS-Tests-predicates&gt;&gt;

&lt;&lt;XS-Tests-quantification&gt;&gt;
&lt;&lt;XS-Tests-multiple-quantification&gt;&gt;
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgef6725c" class="outline-2">
<h2 id="orgef6725c"><span class="section-number-2">4.</span> Language M:  first-order logic with identity and functions</h2>
<div class="outline-text-2" id="text-4">
<p>
Vis-a-vis language S, language M adds:
</p>
<ul class="org-ul">
<li>identity and the symbol "<code>=</code>"</li>
<li>functions, or more precisely function-call expressions or structures,
e.g. <code>f(x)</code>, denoting individuals</li>
</ul>

<p>
These often go together, but not always.  Quine's <i>Methods of Logic</i>
and Smullyan's <i>First-order logic</i> both include identity but have (as
far as I can tell after some searching) no notation for functions.
Prolog, on the other hand, has structures (which can be regarded,
semantically, as calls to functions) but no built-in way to say that
two constants 'a' and 'b' denote the same individual.  (Unification
can do wonders for variables A and B, but atoms like 'a' and 'b'
cannot be unified.)  Perhaps the only reason we think of them as
belonging together is that identity appears to be essential to
describing uniqueness and thus to saying that any function expression
denotes just one individual.
</p>
</div>

<div id="outline-container-org5e6ac51" class="outline-3">
<h3 id="org5e6ac51"><span class="section-number-3">4.1.</span> Identities</h3>
<div class="outline-text-3" id="text-4-1">
<p>
We add identities as a form of basic proposition.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ Identities }
identity = term, os, -"=", os, term.
</pre>
</div>

<p>
This requires a fresh definition of basic propositions:
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ M: Basic formulas }
-basic-formula = 
        prop-var 
      | prop-constant 
      | predicate
      | identity
      | not
      | bracketed-formula
      .
</pre>
</div>
</div>
</div>

<div id="outline-container-org8fa3683" class="outline-3">
<h3 id="org8fa3683"><span class="section-number-3">4.2.</span> Functions</h3>
<div class="outline-text-3" id="text-4-2">
<p>
The syntax of structures representing references to functions is
identical to that of predicates: a name followed by a list of
comma-separated arguments surrounded by parentheses.  They are
distinguished only by position: predicates appear where formulas
expressing propositions are expected, structures appear where
expressions denoting individuals are expected.
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ Structures / function references }
structure = functor, -"(", os, arg**comma, os, -")".
@functor = @name.
</pre>
</div>

<p>
Structures give us a new kind of term, so we need to
extend the definition from that of language S:
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ M-Terms:  terms for individuals }
-term = var; constant; structure.
</pre>
</div>

<p>
Note that unless special steps are taken to create rules for types,
all functions are required to be defined for every possible argument:
they must be total over the universe of discourse.  (We can of course
define an object named ›GARBAGE‹ and specify it as the value of the
function for every inconvenient argument.  That is not guaranteed to
produce beautiful results.)
</p>

<p>
Note also that since the function syntax always uses parentheses, and
functors are always constants, language M extends the mechanisms for
referring to an individual: a specific individual can be referred to
either by using a constant like "<code>'f'</code>" or "<code>‹f›</code>" or by using a
zero-argument function expression like "<code>f()</code>".
</p>
</div>
</div>

<div id="outline-container-org014915d" class="outline-3">
<h3 id="org014915d"><span class="section-number-3">4.3.</span> Recapitulation of language M</h3>
<div class="outline-text-3" id="text-4-3">
<p>
The grammar of language M can be summarized:
</p>
<div class="org-src-container">
<pre class="src src-ixml">ixml version "1.1".

{ m.ixml:  grammar for first-order logic
  with identity and functions }
m-formulas = os, formula++NL, os.
&lt;&lt;S-Formulas&gt;&gt;
&lt;&lt;XS-Compound-formulas&gt;&gt;
&lt;&lt;Quantification&gt;&gt;
&lt;&lt;M-Basic-formulas&gt;&gt;
&lt;&lt;Identities&gt;&gt;
&lt;&lt;Bracketed-formulas&gt;&gt;

&lt;&lt;Predicates&gt;&gt;
&lt;&lt;XS-Atomics&gt;&gt;
&lt;&lt;M-Terms&gt;&gt;
&lt;&lt;S-Atomics&gt;&gt;
&lt;&lt;Structures&gt;&gt;
&lt;&lt;Quoted-strings&gt;&gt;

&lt;&lt;Logical-operators&gt;&gt;
&lt;&lt;Quantifier-ops&gt;&gt;

&lt;&lt;Basics&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgf8fe928" class="outline-3">
<h3 id="orgf8fe928"><span class="section-number-3">4.4.</span> Tests for language M</h3>
<div class="outline-text-3" id="text-4-4">
<p>
Let us formulate a few examples as test cases for the grammar.
</p>
<div class="org-src-container">
<pre class="src src-data">(x)(some y)(z)(f(x) = z iff z = y)
~(all x, y)[(f('a') = x /\ f(a) = y) implies x=y]

/* Group theory, per Jeffrey */
(x)(y)(z)(plus(x, plus(y, z)) = plus(plus(x, y), z))
(x)(plus(x, 0) = 0)
(x)(plus(x, minus(x)) = 0)
(forall x, y, z)(plus(x, y) = plus(y, z) implies x = y)
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-orgc8235aa" class="outline-2">
<h2 id="orgc8235aa"><span class="section-number-2">5.</span> Language L:  additional convenience features</h2>
<div class="outline-text-2" id="text-5">
<p>
Language L adds a number of convenience features to language M:
</p>
<ul class="org-ul">
<li>typed quantifications (for all <i>x</i> of type <i>T</i>, &#x2026;; there is
some <i>x</i> of type <i>T</i> such that &#x2026;)</li>
<li>unique existential quantification (there exists exactly one
individual such that &#x2026;)</li>
<li>Descriptions / Skolem expressions (the unique individual who &#x2026;)</li>
<li>negated existential quantification (there is no <i>x</i> such that &#x2026;)</li>
<li><i>lone</i> existential quantification (there is at most one <i>x</i> such
that &#x2026;)</li>
</ul>

<p>
These are all intended as idioms for concise expression of commonly
used patterns; for each new construct, we specify a standard
translation into language M.
</p>
</div>

<div id="outline-container-orgc64de05" class="outline-3">
<h3 id="orgc64de05"><span class="section-number-3">5.1.</span> New forms of quantification</h3>
<div class="outline-text-3" id="text-5-1">
<p>
Most of these changes have to do with quantifiers: allowing
them to specify the 'type' of the variable on one hand, and
allowing them to give more information about the number of
individuals involved on the other.  So instead of two forms
of quantification, we will have several:
</p>
<ul class="org-ul">
<li>universal</li>
<li>existential</li>
<li>unique</li>
<li>negated</li>
<li>lone</li>
</ul>
<p>
and for each of these, we'll have both typed and untyped varieties.
This will require some changes to the way quantified formulas are
defined, replacing the definitions from language S.
</p>

<p>
The new definitions are:
</p>
<div class="org-src-container">
<pre class="src src-ixml">{ Quantified formulas in L }
-quantified-formula = all | exist | one | none | lone.

all = universal-quantifier, os, bracketed-formula.
exist = existential-quantifier, os, bracketed-formula.
one = unique-existential-quantifier, os, bracketed-formula.
none = negated-existential-quantifier, os, bracketed-formula.
lone = lone-existential-quantifier, os, bracketed-formula.

-universal-quantifier = 
        -"(", FORALL, vars, os, type-spec?, -")"
      | -"(", os, one-var, os, type-spec?, -")"
      .
-FORALL = os, FORALL-sym, os
      | os, FORALL-lex, RS
      .

-existential-quantifier = 
        -"(", EXIST, vars, os, type-spec?, -")". 
-EXIST = os, EXIST-sym, os
      | os, EXIST-lex, RS
      .

@vars = var ++ comma-space.
@one-var &gt; vars = var.
-comma-space = os, -",", os, +" ".
</pre>
</div>
</div>

<div id="outline-container-orga339ae3" class="outline-4">
<h4 id="orga339ae3"><span class="section-number-4">5.1.1.</span> Typed quantification</h4>
<div class="outline-text-4" id="text-5-1-1">
<p>
In order to make some common kinds of statements more convenient, we
would like to be able to associate variables with classes, or types,
more or less as we can do in most programming languages.  To say, for
example, that all tokens occur in some document and that every
document contains at least one token, we can in language M write:
</p>
<pre class="example" id="org87e3082">
(all k)(Token(k) 
       implies 
       (some d)(Document(d) and contains(d, k)))
(all d)(Document(d) 
       implies 
       (some k)(Token(k) and contains(d, k)))
</pre>
<p>
It often seems simpler and easier to follow if instead we
write:
</p>
<div class="org-src-container">
<pre class="src src-data">(all k: Token)(some d: Document)(contains(d, k))
(all d: Document)(some k: Token)(contains(d, k))
</pre>
</div>

<p>
In our usage,
"<code>(∀x:T)(P(x))</code>" is just short-hand for
"<code>(∀x)(T(x) ⇒ P(x))</code>", and 
"<code>(∃x:T)(P(x))</code>" is just short-hand for
"<code>(∃x)(T(x) ∧ P(x))</code>".
</p>

<p>
The definitions of <i>universal-quantifier</i> and <i>existential-quantifier</i>
given above allow for an optional type specification; the same will
be true of the other new forms of quantification.  A type specification
is just a colon followed by a name.  As illustrated above, this name
is taken as that of the characteristic predicate of the type.
</p>
<div class="org-src-container">
<pre class="src src-ixml">-type-spec = -":", os, type, os.
@type = name.
</pre>
</div>

<p>
Some more examples and test cases:
</p>
<div class="org-src-container">
<pre class="src src-data">(∀x:T)(P(x))
(∃x:T)(P(x))
(∀x: Root)(Object(x))
(∀x: Root)(∀y: Root)(x = y)
(∀x: A)(Object(x))
(∀x: A)(∀y: A)(x = y)
(all x : Type)(~Token(x) and ~Document(x))
(all x : Token)(~Type(x) and ~Document(x))
(all x : Document)(~Type(x) and ~Token(x))
</pre>
</div>
</div>
</div>

<div id="outline-container-org089844d" class="outline-4">
<h4 id="org089844d"><span class="section-number-4">5.1.2.</span> Unique existential quantification</h4>
<div class="outline-text-4" id="text-5-1-2">
<p>
Unique existential quantifiers assert the existence of exactly one
individual such that some proposition holds.
</p>

<p>
To say that every school has exactly one head teacher, one might say
"<code>(∀ s : School)(∃₁ h : Head-teacher)(heads(h, s))</code>".
</p>

<p>
Syntactically, it's similar to the other quantifiers already seen: it
has both symbolic and alphanumeric forms, which have different
requirements with respect to following whitespace.
</p>
<div class="org-src-container">
<pre class="src src-ixml">unique-existential-quantifier = 
        -"(", EXISTS-ONE, vars, os, type-spec?, -")".
-EXISTS-ONE = os, EXISTS-ONE-sym, os
      | os, EXISTS-ONE-lex, RS
      .
@EXISTS-ONE-lex &gt; op = "one" | "ONE"
      | "∃_1" 
      | "exists_1" | "EXISTS_1" 
      | "exist_1" | "EXIST_1" 
      | "E_1"
      .  
@EXISTS-ONE-sym &gt; op = "∃₁" { #2203 + #2081 subscript one }.
</pre>
</div>

<p>
For any variable quantified in this way, the declaration is
short-hand for a conjunction of statements following the pattern
established by Russell.  The table below shows the pattern
of expansion for typed and untyped examples of one and two
variables; for more variables, 
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Shorthand</th>
<th scope="col" class="org-left">Expansion</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(∃₁x)(P(x))</td>
<td class="org-left">(∃x)(P(x) ∧ (∀y)(P(y) ⇒ x=y))</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">(∃₁x:T)(P(x))</td>
<td class="org-left">(∃x)(T(x) ∧ P(x) ∧ (∀y)(T(y) ⇒ (P(y) ⇒ x=y)))</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">(∃₁ x, y)(P(x, y))</td>
<td class="org-left">(∃x)(∃y)(P(x, y)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">∧ (∀ z, w)(P(z, w) ⇒ (x=z ∧ y=w)))</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">(∃₁ x, y : T)(P(x, y))</td>
<td class="org-left">(∃x)(∃y)(T(x) ∧ T(y)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">∧ P(x, y)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">∧ (∀ z, w)((T(z) ∧ T(y))</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">⇒ (P(z, w) ⇒ (x=z ∧ y=w))))</td>
</tr>
</tbody>
</table>

<p>
The final two examples in the table above can be read as saying that
there is just one combination of values for <i>x</i> and <i>y</i> such that
the properties given hold.
</p>

<p>
<i>To show:</i> that the expansion given for a single unique quantification
over multiple variables is logically equivalent to the expansion of
nested unique quantifications.
</p>

<p>
Some examples:
</p>
<div class="org-src-container">
<pre class="src src-data">(∃₁ x)(Root(x))
(one x)(A(x))
(exists_1 x)(B(x))
(all n : Node)(Root(n) or (one p : Node)(parent_child(p, n)))
(all p : Point)(exist_1 x, y: ℕ)
  (x = first(p) and y = second(p))
(exists_1 n : ℕ)(all m : ℕ)[le(n, m)]
</pre>
</div>
</div>
</div>
<div id="outline-container-orgc554a06" class="outline-4">
<h4 id="orgc554a06"><span class="section-number-4">5.1.3.</span> Negated existential quantification</h4>
<div class="outline-text-4" id="text-5-1-3">
<p>
Experience with Alloy suggests that it's quite convenient to be able
to say concisely that there is no individual with some specified
property.
</p>

<p>
The formula "(no x)(P(x))" is strictly equivalent to "¬(∃x)(P(x))".
And "(no x : T)(P(x))" is strictly equivalent to "¬(∃x)(T(x) ∧ P(x))".
</p>

<p>
Because this quantifier is known to us only from Alloy, we
offer only one way to spell it.  (Well, two, since we allow
it to be in all caps.)
</p>
<div class="org-src-container">
<pre class="src src-ixml">negated-existential-quantifier = 
        -"(", NONE, vars, os, type-spec?, -")".
-NONE = os, NONE-lex, RS.
@NONE-lex &gt; op = "no"; "NO".
</pre>
</div>

<p>
<i>To do:</i> Describe the expansion for multiple variables, typed and
untyped, and explain whether it is or is not equivalent to nested
negated existential quantifiers for single variables.  That is: is (no
x, y : T)(P(x, y)) equivalent to (no x : T)(no y : T)(P(x, y)), or
not?
</p>

<p>
Examples:
</p>
<div class="org-src-container">
<pre class="src src-data">/* subtoken relation is acyclic, or equivalently
   tc-subtoken relation is antisymmetric */
(no x : Token)(tc-subtoken(x, x))

/* there is no greatest natural number */
(no n : ℕ)(all m : ℕ)[ge(n, m)]
</pre>
</div>
</div>
</div>
<div id="outline-container-orge9fb1f6" class="outline-4">
<h4 id="orge9fb1f6"><span class="section-number-4">5.1.4.</span> Lone existential quantification</h4>
<div class="outline-text-4" id="text-5-1-4">
<p>
This is another borrowing from Alloy.  It specifies that there is at
most one individual with the specified property: such an individual
may or may not exist, and if they do, then they are unique.
</p>

<p>
The syntax:
</p>
<div class="org-src-container">
<pre class="src src-ixml">lone-existential-quantifier = 
        -"(", LONE, vars, os, type-spec?, -")".
-LONE = os, LONE-lex, RS.
@LONE-lex &gt; op = "lone"; "LONE".
</pre>
</div>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">Shorthand</th>
<th scope="col" class="org-left">Expansion</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">(lone x)(P(x))</td>
<td class="org-left">(∀x)(P(x) → (∀y)(P(y) ⇒ x=y))</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">(lone x: T)(P(x))</td>
<td class="org-left">(∀x)(T(x) ∧ P(x) → (∀y)((T(y) ∧ P(y)) ⇒ x=y))</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">(lone x, y)(P(x, y))</td>
<td class="org-left">(∀ x, y)(P(x, y)</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">→ (∀ z, w)(P(z, w) ⇒ (x=z ∧ y=w)))</td>
</tr>
</tbody>
<tbody>
<tr>
<td class="org-left">(lone x, y: T)(P(x, y))</td>
<td class="org-left">(∀ x, y)((T(x) ∧ T(y) ∧ P(x, y))</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">⇒ (∀ z, w)((T(z) ∧ T(y) ∧ P(z, w))</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-left">⇒ (x=z ∧ y=w))))</td>
</tr>
</tbody>
</table>

<p>
Some examples:
</p>
<div class="org-src-container">
<pre class="src src-data">/* the digraph is connected:  at most one 
   node lacks incoming arcs */
(lone n : Node)(no p : Node)
    (parent_child(p, n))
/* Every mark is in at most one document */
(all m : Mark)(lone d : Document)(contains(d, m))
</pre>
</div>
</div>
</div>
</div>

<div id="outline-container-org1e1c558" class="outline-3">
<h3 id="org1e1c558"><span class="section-number-3">5.2.</span> Definite descriptions / Skolem expressions</h3>
<div class="outline-text-3" id="text-5-2">
<p>
On descriptions see Quine <i>Methods</i> 274-282 (or so).
</p>

<div class="org-src-container">
<pre class="src src-ixml">the = "℩" { #2129 turned Greek small letter iota }
    | "the"
    .
</pre>
</div>

<p>
Some examples would be helpful.
</p>
<div class="org-src-container">
<pre class="src src-data">/* watch this space */
</pre>
</div>
</div>
</div>
<div id="outline-container-org7b1e93b" class="outline-3">
<h3 id="org7b1e93b"><span class="section-number-3">5.3.</span> Recapitulation of language L</h3>
<div class="outline-text-3" id="text-5-3">
<p>
The grammar of language L can be summarized:
</p>
<div class="org-src-container">
<pre class="src src-ixml">ixml version "1.1".

{ l.ixml:  grammar for first-order logic
  with identity and functions,  augmented
  with convenience features. }
m-formulas = os, formula++NL, os.
&lt;&lt;S-Formulas&gt;&gt;
&lt;&lt;XS-Compound-formulas&gt;&gt;

&lt;&lt;L-Quantification&gt;&gt;
&lt;&lt;Type-specification&gt;&gt;
&lt;&lt;Unique-quantifier&gt;&gt;
&lt;&lt;Negated-quantification&gt;&gt;
&lt;&lt;Lone-quantification&gt;&gt;

&lt;&lt;M-Basic-formulas&gt;&gt;
&lt;&lt;Identities&gt;&gt;
&lt;&lt;Bracketed-formulas&gt;&gt;

&lt;&lt;Predicates&gt;&gt;
&lt;&lt;XS-Atomics&gt;&gt;
&lt;&lt;M-Terms&gt;&gt;
&lt;&lt;S-Atomics&gt;&gt;
&lt;&lt;Structures&gt;&gt;
&lt;&lt;Quoted-strings&gt;&gt;

&lt;&lt;Logical-operators&gt;&gt;
&lt;&lt;Quantifier-ops&gt;&gt;

&lt;&lt;Basics&gt;&gt;
</pre>
</div>
</div>
</div>

<div id="outline-container-orgdc402e3" class="outline-3">
<h3 id="orgdc402e3"><span class="section-number-3">5.4.</span> Test cases for language L</h3>
<div class="outline-text-3" id="text-5-4">
<p>
We can collect all the examples given above and
use them as positive test cases for language L.
</p>
<div class="org-src-container">
<pre class="src src-data">&lt;&lt;Typed-01&gt;&gt;
&lt;&lt;Typed-02&gt;&gt;
&lt;&lt;Unique&gt;&gt;
&lt;&lt;Negated-existentials&gt;&gt;
&lt;&lt;Lone-quantifiers&gt;&gt;
</pre>
</div>
</div>
</div>
</div>
<div id="outline-container-org38f5460" class="outline-2">
<h2 id="org38f5460"><span class="section-number-2">6.</span> Language XL: first-order logic plus set theory</h2>
<div class="outline-text-2" id="text-6">
<p>
Language XS adds sets <i>(and tuples? tbd)</i> to the universe of
discourse.  Concretely it adds:
</p>
<ul class="org-ul">
<li>the ability to declare variables as denoting sets of a given type</li>
<li>syntax for tuples</li>
<li>the ability to declare variables as denoting tuples in a given
relation (with symbols allowing the user to distinguish total
from partial functions, injections, and bijections)</li>
<li>symbols for standard set operations (membership, complementation,
union, intersection, subset relation, set difference)</li>
<li>set comprehensions</li>
</ul>

<p>
/(The inclusion of tuples, set comprehensions, and various forms of
functions and relations is uncertain.  Our initial instinct was to
exclude them for simplicity and reliability, since the ground has
proved so treacherous for so many.  But it may be that once sets are
added, we have tuples and relations whether we want them or not.  And
in that case, we might as well have set comprehensions to make them
easier to talk about.)/
</p>

<p>
[Full definition to be supplied.]
</p>
</div>
</div>

<div id="outline-container-org34b7a1b" class="outline-2">
<h2 id="org34b7a1b"><span class="section-number-2">7.</span> Concluding notes</h2>
<div class="outline-text-2" id="text-7">
<p>
The grammars defined here have two intended functions:
</p>
<ul class="org-ul">
<li>They provide specific targets for programs we write
which are to translate some notation or other into
'conventional first-order logic'.  That is, they allow
that vague description to be replaced by a statement
that the program's output is or should be sentences
in one of the languages defined here.</li>
<li>They make it easy to translate formulas into XML form
so they can be processed by XSLT or XQuery programs.  
We may write pretty-printers, normalizers, and (of course)
translations into specific target notations like ACL2
or TPTP FOF or TFF.</li>
</ul>

<p>
At first glance, it may seem excessive to formulate test cases
for such a simple collection of grammatical rules.  But the tests
have caught a number of errors in the grammar.
</p>
</div>

<div id="outline-container-orgdf36ef9" class="outline-3">
<h3 id="orgdf36ef9"><span class="section-number-3">7.1.</span> To do</h3>
<div class="outline-text-3" id="text-7-1">
<p>
Watch this space.
</p>
</div>
</div>

<div id="outline-container-org46278df" class="outline-3">
<h3 id="org46278df"><span class="section-number-3">7.2.</span> Questions to consider</h3>
<div class="outline-text-3" id="text-7-2">
<p>
At the time this paper was last revised (May 2024 or later), several
questions seemed to merit further consideration.  They are not
strictly speaking open questions, in so far as the grammars given here
provide specific answers to them.  But they are questions in whose
answers the authors do not currently feel completely confident.  Those
we remembered to write down are:
</p>

<ul class="org-ul">
<li><p>
Q. Should subscripts be allowed in identifiers?
</p>

<p>
A. They already are.  The only effective way to allow subscripts is
to provide some convenient typographic shorthand for them; the
obvious choice is to separate the base name from the subscript with
an underscore: thus <i>x</i> with a subscribt of 1 can be written
<code>x\zwnj{}_1</code>, which can in HTML or on paper be formatted as <i>x<sub>1</sub></i>.
But this is already allowed.
</p>

<p>
Perhaps underscore should be allowed in identifiers <i>only</i> with the
meaning 'subscript'?  And thus only when followed by decimal digits?
</p>

<p>
Tentative answer:  unnecessary.
</p></li>

<li>Q. Include an explicit notation for tuples in language XL?</li>

<li>Q. Include explicit notation(s) for sequences in language XL?</li>

<li><p>
Q. Define variant grammars with less variation in the spelling of
operators?
</p>

<p>
Tentative answer: unnecessary.  Consistency of spelling is important
for presentation, but not for ingestion of formulas.  A normalizer
can easily be written to reserialize formula sequences in any
desired form with consistent spelling (and optionally
pretty-printing).
</p></li>

<li>Add <i>xor</i> (aka <i>aut</i>), <i>nand</i>, <i>nor</i>?</li>

<li>Eliminate propositional terms in S through XL / allow them only in
XS?</li>

<li>Allow marking variables with "<code>$</code>"?</li>

<li>Allow other forms of numbers as individual constants? (Currently
only unsigned integers are allowed.  And it's only the sentence
about Frege being born in 1848 that motivates that.)</li>

<li><p>
Are we sure we want to allow negation to bind more tightly than the
binary operators?
</p>

<p>
I got tired of having add parentheses, so I added negation as a
'basic' formula.  We need to think about it more when we have more
experience.
</p></li>

<li>In L, borrow Alloy's ability to specify that particular variables
are disjoint?</li>
</ul>
</div>
</div>

<div id="outline-container-orgb0149e6" class="outline-3">
<h3 id="orgb0149e6"><span class="section-number-3">7.3.</span> Done</h3>
<div class="outline-text-3" id="text-7-3">
<p>
Temporary list of to-do items now completed.
</p>
<ul class="org-ul">
<li>Split all operators into symbolic and alphabetic forms.
Adjacent space is optional for symbolic form, required
for alphabetics.  I think this works already for quantifiers,
but the current grammar allows <code>born('Frege', 1848)</code> to be
parsed either as intended or as equivalent to
<code>b ∨ n('Frege', 1848)</code>, which is going too far.</li>
<li>Create minimal test case exhibiting <i>vars</i> problem, report
to Markup Blitz.</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 16 May 2024</p>
<p class="author">Author: CMSMcQ and CH</p>
<p class="date">Created: 2024-05-25 Sat 08:58</p>
<p class="validation"><a href="https://validator.w3.org/check?uri=referer">Validate</a></p>
</div>
</body>
</html>
