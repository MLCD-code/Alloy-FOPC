#+title: Experiments with tree models in Alloy
#+author: CMSMcQ 
#+date: 28 March - 12 April 2024, resumed 2-4 May 2024

This document describes a translation of some simple Alloy models of
trees into first-order logic and some experiments with translating
them into first-order logic.  

The models are borrowed from teaching materials for a course on
software testing published on the web by Jan van Eijck of the
University of Amsterdam, specifically from the lecture notes on
[[https://staff.fnwi.uva.nl/d.j.n.vaneijck2/courses/10/pdfs/Week4.pdf][Specifications and assertions]].

The document was written bit by bit and thus has some characteristics
of a work log.  In particular, the bits at the beginning don't know
for sure where the last bits are going, and there are digressions and
notes about things that may or may not be important but which I don't
want to forget.  The reader is requested to be patient.

* The first Alloy model

** The Alloy

The first model appears on slide 3:
#+begin_src alloy
/* Tree Specification in Alloy */
module myexamples/tree

sig Object { b: set Object }
one sig Root, A, B, C, D extends Object {}

fact OneRoot { all x: Object | x = Root <=> no b.x }
fact b_acyclic { no ^b & iden }

fact { C in B.b and D in C.b }

pred show () {}
run show for 5
#+end_src

A (slightly rough) English paraphrase might be as follows.
From the signature declarations, we have:
  - Objects Root, A, B, C, and D exist; there are no other objects.
  - Each object has a field /b/ (for /branches/ or /branching/
    relation) whose value is a set of objects.  Informally: for any
    object /X/, /X.b/ is the set of /X/'s children.

    Note that /b/ can also be described simply as a binary relation
    /b/ on objects.

From the fact /OneRoot/ we have:
  - An object is the Root object if and only if it is not a member of
    the value of /b/ for any object.

From the fact /b\under{}acyclic/ we have:
  - The intersection of the transitive closure of /b/ (viewed as a
    binary relation) and the identity relation is empty (i.e. they are
    disjoint).  This means, in effect, that no object /X/ can be
    reached by starting at /X/ and traversing the /b/ relation any
    positive number of times.

From the unnamed third fact we have:
  - Object C is a member of the /b/ field of B (i.e. C is one of B's
    children), and D is a child of C.

The predicate /show/ imposes no constraints, so it hold for any
instance of the model; the /run/ command, when executed, asks Alloy to
find an instance of the predicate /show/ in a universe with at most 5
objects of any signature.

** The FOPC translation

*** The signature declarations

In our usual first-order calculus notation, we can perhaps render this
model as follows.

There is only one top-level signature, so everything is either an
object or a member of an automatically supplied signature (like Int),
and nothing is both.
#+begin_src fopc
(∀x)(Object(x) aut AUTO(x))
#+end_src

The five signatures Root, A, B, C, D are all sub-signatures of Object,
and each is declared with a cardinality of one.  That means first that
there is at least one individual in each of these signatures, and then
also that any individual which is a member of these signatures is an
object, and if /x/ and /y/ are members of one of these signatures,
then /x/ and /y/ are the same individual.

#+begin_src fopc
(∃x)(Root(x))
(∀x: Root)(Object(x))
(∀x: Root)(∀y: Root)(x = y)
(∃x)(A(x))
(∀x: A)(Object(x))
(∀x: A)(∀y: A)(x = y)
(∃x)(B(x))
(∀x: B)(Object(x))
(∀x: B)(∀y: B)(x = y)
(∃x)(C(x))
(∀x: C)(Object(x))
(∀x: C)(∀y: C)(x = y)
(∃x)(D(x))
(∀x: D)(Object(x))
(∀x: D)(∀y: D)(x = y)
#+end_src

Furthermore, the sub-signatures partition the parent signature:
#+begin_src fopc
(∀x: Object)(Root(x) aut A(x) aut B(x) aut C(x) aut D(x))
#+end_src

Without typed declarations and without exclusive or, these become a
bit wordier.

#+begin_src fopc
(∀x)(Object(x) ∨ AUTO(x))
¬(∃x)(Object(x) ∧ AUTO(x))
(∃x)(Root(x))
(∀x)(Root(x) ⇒ (Object(x) ∧ (∀y)(Root(y) ⇒ x = y)))
(∃x)(A(x))
(∀x)(A(x) ⇒ (Object(x) ∧ (∀y)(A(y) ⇒ x = y)))
(∃x)(B(x))
(∀x)(B(x) ⇒ (Object(x) ∧ (∀y)(B(y) ⇒ x = y)))
(∃x)(C(x))
(∀x)(C(x) ⇒ (Object(x) ∧ (∀y)(C(y) ⇒ x = y)))
(∃x)(D(x))
(∀x)(D(x) ⇒ (Object(x) ∧ (∀y)(D(y) ⇒ x = y)))
(∀x)(Object(x) ⇒
        ((Root(x) ∨ A(x) ∨ B(x) ∨ C(x) ∨ D(x))
         ∧ ¬(Root(x) ∧ A(x))
         ∧ ¬(Root(x) ∧ B(x))
         ∧ ¬(Root(x) ∧ C(x))
         ∧ ¬(Root(x) ∧ D(x))
         ∧ ¬(A(x) ∧ B(x))
         ∧ ¬(A(x) ∧ C(x))
         ∧ ¬(A(x) ∧ D(x))
         ∧ ¬(B(x) ∧ C(x))
         ∧ ¬(B(x) ∧ D(x))
         ∧ ¬(C(x) ∧ D(x)))
#+end_src

*** The fact /OneRoot/

/OneRoot/ says that for all objects, the object is the Root if and
only if no object has it as a child.

#+begin_src fopc
(∀x: Object)(Root(x) ⇔ ¬(∃y)(b(y, x)))
#+end_src

*** The fact /b\under{}acyclic/

The fact /b\under{}acyclic/ is, closely paraphrased, a statement
about the cardinality of a set.

We cannot define the transitive closure operator "~^~" in a
first-order system, so we will need to define the transitive closure
of /b/ as a named relation, which we'll call /tcb/ for 'transitive
closure of b'.  It can be defined recursively in a pattern familiar
from other recursive definitions.
#+begin_src fopc
(∀ x, y)(tcb(x, y) 
          ⇔ 
          (b(x,y) ∨ (∃z)(b(x,z) ∧ tcb(z,y))))
#+end_src

We may need to define /iden/ as well:
#+begin_src fopc
(∀ x, y)(iden(x, y) ⇔ x = y)
#+end_src

A direct translation of the fact might then be:
#+begin_src fopc
¬(∃ x, y)(tcb(x, y) ∧ iden(x, y))
#+end_src

For complex expressions denoting relations, it might be
better to reify and name the relations denoted by the
subexpressions.  We have already done that for "~^b~" and
"~iden~" here, so we are already part-way there.  A blind
reification of each level in the structure would replace
the direct translation with another reification and then
a simpler statement of the fact:
#+begin_src fopc
(∀x, y)(tcb_inter_iden(x, y) 
          ⇔
          (tcb(x, y) ∧ iden(x, y)))
¬(∃ x, y)(tcb_inter_iden(x, y))
#+end_src
*** The nameless fact
The third fact specifies that B is the parent of C and C the parent of
D.  Or, more precisely, that the single atom of signature B is the
parent of the single atom of signature C, and so on.  Or, given that
they are unique, more simply it says that for any atoms x, y, and z
of signature B, C, and D respectively, the parent/child relation /b/
holds for the pairs (x, y) and (y, z).
#+begin_src fopc
(∀x : B)(∀y : C)(∀z : D)(b(x, y) ∧ b(y, z))
#+end_src
/Later note:/ The formulation just given exploits our knowledge of the
cardinalities in a way that makes it hard to produce mechanically.  If
we stick to the surface meaning of the Alloy formulation ~C in B.b and
D in C.b~, without applying other knowledge, we would want something
more like the following.
#+begin_src fopc
(all x : B)(some y : C)(b(x, y))
and
(all y : C)(some z : D)(b(y, z))
#+end_src
It ought to be possible to show that from the more elaborate
translation just given and the signature facts that say that
/B/, /C/, and /D/ are singletons, the earlier statement follows.


* Checking an example

** The example 
Given the model above, Alloy can generate examples, including one we
can display as a nested list:

- Root
  + B
    - C
      + D
  + A

Or, as an image:

[[./images//jve-tree.dot.png]]

Can we prove in first-order logic what Alloy has told us, namely
that this instance is consistent with the constraints of the model?

** Expressing the example in FOPC

I'm not completely certain of the right way to express this instance
as a set of formulas in our target language, but a first cut would be:

#+begin_src fopc
b(Root, B)
b(Root, A)
b(B, C)
b(C, D)
#+end_src

On further consideration, however, I see that this assumes that the
signature names are constants designating individuals, which is wrong
in several ways.  A second attempt to describe the example says that
in the state of affairs reflected in it, there are five individuals,
one for each declared signature, and they have the relations shown.
Since the uniqueness of each signature has already been established
(or should have been), we don't need to specify that there are exactly
five such individuals but can focus on their signatures and relations.

We can conceive of this as a predicate that holds for five
individuals, which might be declared in Alloy this way:
#+begin_src alloy
pred example[x: Root, y: A, z: B, w: C, v: D] {
 y in b[x]
 z in b[x]
 w in b[z]
 v in b[w]
}
#+end_src
Mnemonic names (/a/ for the member of signature /A/, for example)
would be nicer, but /b/ as the name both for the relation /b/ and the
atom /b/ of signature /B/ was a step too far for me.  (I believe it's
also a step too far for the TPTP theorem provers we are using.)

We could also conceive of our description of the example as a
predicate that takes no arguments but is just true or not true.
#+begin_src fopc
pred example {
 some x: Root, y: A, z: B, w: C, v: D {
   y in b[x]
   z in b[x]
   w in b[z]
   v in b[w]
 }
}
#+end_src
We can translate either of these into FOL; let's pick the second.
#+begin_src fopc
example ⇔ (
  (∃ x, y, z, w, v)
  ( (Root(x) ∧ A(y) ∧ B(z) ∧ C(w) ∧ D(v)
    ∧ b(x, y)
    ∧ b(x, z)
    ∧ b(z, w)
    ∧ b(w, v)
)
#+end_src

** How to check that the example is allowed?

[Note: the discussion below exhibits a certain amount of confusion
about how to check examples.  That task has since come to seem
simpler, but the confused discussion below is retained, since it
illustrates that our current understanding did not always seem
obvious.]

If there can be no instance that satisfies the statements just given
(call their conjunction /E/), then both of the following formulations
of the state of affairs will be true:

- The constraints of the model entail ¬/E/.
- The conjunction of /E/ with the constraints of the model will be
  inconsistent.

Since entailment of /E/ by /M/ is established, in many systems, by
showing that the conjunction /M/ ∧ ¬/E/ is inconsistent, these two
statements boil down to the same thing.

Let's try it.

It may be worth pointing out that this particular example poses no
great difficulty -- it was produced by Alloy, which is very good at
producing instances compatible with the constraints of a model, and
the example is simple enough that one can easily see that it's
consistent with the model.  Moreover, it's small enough that one could
in a pinch assume five individuals and generate a complete set of
closed clauses and a complete set of literals, and show that the set
of literals has no contradictions.  The point of trying to use a
theorem prover to show that the example is consistent with the
constraints is to gain a tool for use on manually constructed examples.

** A TPTP translation of the model and example

In TPTP notation, first-order formulas are labeled as such and 
given names and roles.  So the overall structure of each formula
will match the following grammar (I'm ignoring whitespace for
simplicity):
#+begin_src ixml
tptp-formula: "fof(", name, ",", role, ",", formula, ")".
name: [L], [L; Nd; "_"]*.
role: "axiom"      { start here }
    ; axiom-like
    ; "conjecture" { formula to be proved }
    ; other-roles
    .
axiom-like: "hypothesis" { assumed true, used like axioms }
          ; "definition" { universally quantified equations 
                           or equivalences with atomic LHS,
                           intended to define symbols }
          ; "assumption" { like axiom but "must be discharged
                           before a derivation is complete" }
          ; "lemma"      { has been proved, must follow from axioms }
          ; "theorem"    { has been proved, must follow from axioms }
                         { problem with non-redundant lemma or theorem
                           is ill-formed }
         
other-roles: { probably irrelevant for us? }
             "corollary" | "negated_conjecture" | "plain" 
           | "type" | "interpretation" | "fi_domain" | "fi_functors" 
           | "fi_predicates" | "unknown".
formula: ...
#+end_src

The FOPC rules given above can, I think, be rendered into TPTP as
follows.  Some notes:
- Since TPTP uses the Prolog convention of spelling variables with
  initial uppercase letters and requiring functors to begin with
  lowercase letters (or be quoted), I've lowercased all the signature
  names.
- The theorem prover E objects if the same predicate symbol is used
  with different arities, so this TPTP translation writes "~pc(X, Y)~"
  where the logical rules given above write "b(x, y)".

#+begin_src tptp :tangle ../examples/tree.jve1.axioms.p
/* Signature Object */
fof(sigo1, axiom,
   ( ! [X] : (object(X) | auto(X)))).
fof(sigo2, axiom,
   (~ ? [X] : (object(X) & auto(X)))).

/* Signatures root, a, b, c, d */
fof(sigr1, axiom, (?[X] : root(X))).
fof(sigr2, axiom, 
    ( ! [X] : (root(X) => (object(X) & ( ! [Y] : (root(Y) => (X = Y)))))) ).
fof(siga1, axiom, (?[X] : a(X))).
fof(siga2, axiom, 
    ( ! [X] : (a(X) => (object(X) & ( ! [Y] : (a(Y) => (X = Y)))))) ).
fof(sigb1, axiom, (?[X] : b(X))).
fof(sigb2, axiom, 
    ( ! [X] : (b(X) => (object(X) & ( ! [Y] : (b(Y) => (X = Y)))))) ).
fof(sigc1, axiom, (?[X] : c(X))).
fof(sigc2, axiom, 
    ( ! [X] : (c(X) => (object(X) & ( ! [Y] : (c(Y) => (X = Y)))))) ).
fof(sigd1, axiom, (?[X] : d(X))).
fof(sigd2, axiom, 
    ( ! [X] : (d(X) => (object(X) & ( ! [Y] : (d(Y) => (X = Y)))))) ).

/* Root, A-D partition Object */
fof(sigosubs, axiom,
    ( ! [X] : ( object(X) =>
              ( (root(X) | a(X) | b(X) | c(X) | d(X))
                & ~(root(X) & a(X))
                & ~(root(X) & b(X))
                & ~(root(X) & c(X))
                & ~(root(X) & d(X))
                & ~(a(X) & b(X))
                & ~(a(X) & c(X))
                & ~(a(X) & d(X))
                & ~(b(X) & c(X))
                & ~(b(X) & d(X))
                & ~(c(X) & d(X)))))).

/* fact OneRoot */
fof(oneroot, axiom,
   (![X]: (root(X) <=> (~?[Y]: (pc(Y,X)))))).

/* definition of tcb (^b) */
fof(def_tcb, axiom,
   (![X, Y]: (tcb(X, Y) <=> ((pc(X, Y))|(?[Z]:(pc(X, Z) & tcb(Z, Y))))))).

/* fact b_acyclic */
fof(b_acyclic, axiom,
  (~?[X, Y]:(tcb(X,Y) & (X = Y)))).

/* fact 3 (nameless) */
fof(fact3, axiom,
   (![X,Y,Z] : ((b(X) & c(Y) & d(Z)) => (pc(X, Y) & pc(Y, Z))))).
#+end_src

The example translates into TPTP syntax as follows:
#+begin_src tptp :tangle ../examples/tree.jve1.ex-def.p
/* Definition of example */
fof(example1, definition,
  (example <=> ?[X, Y, Z, W, V] :
               (root(X) & a(Y) & b(Z) & c(W) & d(V)
                & pc(X,Y) & pc(X,Z) & pc(Z,W) & pc(W,V)))).
#+end_src

** Testing ways to run the example

*** Initial attempt to test the example

[Note: the approach described here does not now appear to be the
simplest way to check that an example is consistent with the axioms.]

To check whether the example is possible, we can ask the prover to prove
that it is impossible.
#+begin_src tptp :tangle ../examples/tree.jve1.ex-neg-conj.p
fof(ex1nogo, conjecture, ~example).
#+end_src

If we place the TPTP description of the model, with this conjecture,
in a file named /tree.jve1.p/ and pass it to the theorem prover /E/,
with "~eprover --auto --output-file=tree.jve1.e.out tree.jve1.p~",
then (as expected) /E/ fails to prove the conjecture.

For the record: the version of /E/ I'm running appears to be 2.6
"Floral Guranse".

(One detail was a little puzzling.  I thought that the default value
for the /--cpu-limit/ option was 300 (seconds), but /E/ ran for half
an hour or so and produced 35 MB of output before I stopped it.
Closer examination of the output of "~eprover -h~" shows my
misunderstanding.  What it says is "The option without the optional
argument is equivalent to ~--cpu-limit=300~."  That is, if you specify
"~--cpu-limit~", you get 300 seconds.)

Unfortunately, any automated theorem prover will sometimes fail to
prove a true conjecture, so this is not completely satisfactory.  What
we would like is a clear indication that the example is consistent
with the assumptions.  In a tableau proof, we can (at least in some
cases) produce a proof tree which is not closed but is complete, and
we can construct a counterexample to the conjecture by reading off the
values for various literals by running down any open branch.  Can we
do that, or something analogous, with /E/ or with any other theorem
prover?

*** Diagnosing the problem

After a digression to a simpler example, I tried this again, with a
soft CPU limit of 30 seconds.  It timed out.

Next, I tried a primitive binary chop.
1. Tried the first half of the model (down to axiom /sigd2/
   inclusive).  It showed the (truncated) model satisfiable, in
   about 15 msec.
2. Added /sigosubs/ and /oneroot/; that is 42 lines of 63.
   Satisfiable, 23 msec.
3. Added /def\under{}tcb/ and /b\under{}acyclic/.  I wonder if the
   recursion here is part of the problem.  It is; /E/ times out.
4. Leave the definition of tcb in place, but comment out the
   translation of /b\under{}acyclic/.  Still times out.
5. Comment out the two axioms added in step 3 of this diagnostic
   process, restore all the others: /fact3/, /example/.  Times out.
6. Comment out definition of /example/.  Shown satisfiable in 23 msec.
7. Try alternate definition of example (as predicate of arity 5).
   Satisfiable, 23 msec.

Retrying the two definitions of the example, one making /example/ a
proposition true iff there are five individuals with a given
configuration and the other making it a predicate over five arguments,
I find that I am unable to replicate the timing shown for step 5.
Either way it takes a little over 20 milliseconds.

*** A simpler way

As the reader may know, some automatic theorem provers work by
assuming the negation of the conjecture and deriving a contradioction
-- a sort of mechanized /reductio ad absurdum/.  In such a theorem
prover, it should be straightforward to see whether a set of axioms is
consistent, without trying to prove a theorem.

And behold! some such provers -- at least E and Vampire -- are
perfectly happy to do this.

So a simpler and more reliable way to show that the example is
consistent with the axioms is to feed the prover input containing:
- the axioms shown above
- the definition of a predicate representing the example 
- the example-predicate as a hypothesis as shown below.
  
#+begin_src tptp :tangle ../examples/tree.jve1.ex-hyp.p
fof(ex1nogo, hypothesis, example).
#+end_src

If there is no conjecture in the input, both E and Vampire will take
their task to be checking the axioms and hypotheses for
satisfiability.  (The author of E is explicit that finding models for
sets of axioms is not E's strength, and other provers may do better.)

The simplest way to combine the axioms with different conjectures and
hypotheses will be to write the axioms to one file, the conjectures
and hypotheses to different files, and then combine them before
calling the provers.  Both E and Vampire accept a problem description
on the standard input, so the shell command can look like this:

#+begin_example
cat tree.jve1.axioms.p \
    tree.jve1.ex-def.p \
    tree.jve1.ex-hyp.p \
  | eprover --auto \
            --soft-cpu-limit=120 \
            --output-level=0
#+end_example

First, the three files containing the axioms, the definition of the
predicate /example/, and the hypothesis that /example/ holds are
concatenated using /cat/ and fed into the standard input port of E,
invoked with a soft CPU limit of 120 seconds, in 'automatic' mode
(which is what the documentation recommends as "the easiest way to
get good performance".

When we invoke E as shown, it times out without producing a result.
Using the ~--auto-schedule~ option causes E to try an array of
strategies, but none succeed here.

Vampire can be invoked thus:
#+begin_example
cat tree.jve1.axioms.p \
    tree.jve1.ex-def.p \
    tree.jve1.ex-hyp.p \
  | vampire --mode casc_sat \
            -t 30
#+end_example

Here, we have specified a time limit of 30 seconds, and a ~case_sat~
mode, which implements a strategy used in CASC competitions for
problems whose specifications are expected to be satisfiable.

Invoked with mode ~case_sat~, Vampire tries a portfolio of approaches,
one of which succeeds and produces the message "Finite Model Found!"
The logging output is a little terse, but seems to indicate that the
successful approach involved choosing "~fmb~" (for 'finite model building
for satisfiable problems') as the 'saturation algorithm'.  So a more
direct way to get a result here is to invoke Vampire with the option
"~-sa fmb~".

Note:  using the fmb option appears to cause some sort of problem.
Immediately after the "Finite Model Found!" message, I get the messages
#+begin_example
% SZS status Satisfiable for 
164958 Aborted by signal SIGSEGV on 
#+end_example
followed by normal-looking output from Vampire.

* Checking an assertion

Having presented the example above, van Eijck remarks:
#+begin_quote
- This looks OK, but is it?
- Hmm, maybe not. We forgot to say that every other object but
  the root has exactly one B-predecessor.
- Maybe it follows from our specification. Let us check.
#+end_quote

He then suggests an assertion that can be checked:
#+begin_src alloy
assert SingleParent
  { all x,y,z: Object | z in x.b and z in y.b => x=y }
check SingleParent for 5
#+end_src

Alloy checks the assertion by finding a counter-example within
the scope specified; in principle, a prover can check
the assertion more broadly (although it's clear that in practice
at least some disproofs are going to take the form of finding
a counter-example).

#+begin_src tptp :tangle ../examples/tree.jve1.conj-single-parent.p
fof(single_parent, conjecture,
  ![X, Y, Z] : ((object(X) & object(Y) & object(Z)) =>
               ((pc(X,Z) & pc(Y,Z)) => (X = Y)))
).
#+end_src

How does that in-principle checking work out in practice?  Since this
conjecture is known to be false, we are not expecting any theorem
prover to produce a proof, and it is not surprising that none do.  It
would be nice to have a clear statement that the generalization is
false, possibly with a counter-example.  Here, results are mixed.

- When E is invoked with ~--auto-schedule~, each tactic it tries times
  out before reaching a conclusion.
- When Vampire is invoked with ~--mode casc~, it too fails to prove
  the conjecture; some of its tactics time out, while others report
  only "Refutation not found, incomplete strategy".
- When Vampire is invoked with ~--mode case_sat~~, however, the tactic
  summarized as "fmb+10\under{}1\under{}av=off : fmbsr=1.6 : lma=on : nm=64 :
  nwc=3 : sp=reverse\under{}arity : urr=on\under{}258" reports "Finite Model Found!"
  and signals an SZS status of "CounterSatisfiable".

This appears consistent with the observation that for software, the
task of finding models (or counter-examples) and that of finding
proofs are distinct problems which require different approaches,
however much they may overlap in principle.

* A second Alloy model

The second model appears on slide 7 of van Eijck's presentation; it
changes /SingleParent/ from being an assertion to being a fact.
#+begin_src alloy
/* Corrected specification */
module myexamples/tree

sig Object { b: set Object }
one sig Root, A, B, C, D extends Object {}
fact OneRoot { all x: Object | x = Root <=> no b.x }
fact SingleParent
  { all x,y,z: Object | z in x.b and z in y.b => x=y }
fact b_acyclic { no ^b & iden }

fact { C in B.b and D in C.b }

pred show () {}
run show for 5
#+end_src

The English paraphrase is the same as before, with one addition for
the fact /SingleParent/:

- No object is in the value of /b/ for two distinct parent objects.

In conventional predicate calculus, this could be written:
#+begin_src fopc
(∀ x, y, z)((Object(x) ∧ Object(y) ∧ Object(z))
    ⇒ ((pc(x, z) ∧ pc(y, z))
        ⇒ (x = y)))
#+end_src

A TPTP rendering is essentially the same as above, with /conjecture/
changed to /axiom/:

#+begin_src tptp :tangle ../examples/tree.jve1.ax-single-parent.p
fof(single_parent, conjecture,
  ![X, Y, Z] : ((object(X) & object(Y) & object(Z)) =>
               ((pc(X,Z) & pc(Y,Z)) => (X = Y)))
).
#+end_src

Van Eijck formulates no conjectures or assertions relating to this
modified model.  We could think of some on our own, but that seems too
much like work.  So we move on to van Eijck's third model.

* A third model

** The Alloy of slide 10

On slide 9, van Eijck considers the definition of trees starting not
from a branching relation /b/ but from a parenthood relation /P/.  He
identifies three requirements:

- There is exactly one root, defined as an object without parents
  (/P/-successors)
- Every other object has exactly one /P/-successor (parent).
- The relation /P/ is acyclic.

In Alloy:
#+begin_src alloy
module myexamples/newtree

sig Object { p: lone Object }
one sig Root, A, B, C, D extends Object {}

fact OneRoot { all x: Object | x = Root <=> no x.p }
fact SingleParent
  { all x,y,z: Object | y in x.p and z in x.p => y=z }
fact p_acyclic { no ^p & iden }

fact { C in p.B and D in p.B }

pred show () {}
run show for 5
#+end_src

** Equivalent in FOPC

We can render this new model in first-order logic as follows.

The description of the signatures is the same as above:
#+begin_src fopc
// Everything is an Object or else it's automatically
// supplied by Alloy.  Nothing is both.
(∀x)(Object(x) ∨ AUTO(x))
¬(∃x)(Object(x) ∧ AUTO(x))

// Subsignatures Root, A, B, C, D have one instance each.
(∃x)(Root(x))
(∀x)(Root(x) ⇒ (Object(x) ∧ (∀y)(Root(y) ⇒ x = y)))

(∃x)(A(x))
(∀x)(A(x) ⇒ (Object(x) ∧ (∀y)(A(y) ⇒ x = y)))

(∃x)(B(x))
(∀x)(B(x) ⇒ (Object(x) ∧ (∀y)(B(y) ⇒ x = y)))

(∃x)(C(x))
(∀x)(C(x) ⇒ (Object(x) ∧ (∀y)(C(y) ⇒ x = y)))

(∃x)(D(x))
(∀x)(D(x) ⇒ (Object(x) ∧ (∀y)(D(y) ⇒ x = y)))

// The subsignatures partition the set of Objects.
(∀x)(Object(x) ⇒
        ((Root(x) ∨ A(x) ∨ B(x) ∨ C(x) ∨ D(x))
         ∧ ¬(Root(x) ∧ A(x))
         ∧ ¬(Root(x) ∧ B(x))
         ∧ ¬(Root(x) ∧ C(x))
         ∧ ¬(Root(x) ∧ D(x))
         ∧ ¬(A(x) ∧ B(x))
         ∧ ¬(A(x) ∧ C(x))
         ∧ ¬(A(x) ∧ D(x))
         ∧ ¬(B(x) ∧ C(x))
         ∧ ¬(B(x) ∧ D(x))
         ∧ ¬(C(x) ∧ D(x)))
#+end_src

The declaration of /Object/ tells us that Objects have a field named
/p/, the optional value of which is an Object.  In relational terms,
this means that:
- for any object /x/, there is at most one object /y/ for which
the relation /p(x, y)/ holds;
- if /p(x, y)/ holds, then /x/ and /y/ are objects.

#+begin_src fopc
(∀ x, y)(p(x, y) ⇒ (∀z)(p(x, z) ⇒ (z = y)))
(∀ x, y)(p(x, y) ⇒ (Object(x) ∧ Object(y)))
#+end_src

Two things should be noted about the second formula, regarding the
types of /p/'s arguments:
- It also applies to the /b/ relation in the first specification of
  trees, although we failed to formulate it there.
- Alloy allows relation names to be overloaded, so the right-hand side
  of the implication will, in the general case, be a disjunction of
  statements about possible argument types.  (Overloading will also
  affect the cardinality constraints.)

The fact /OneRoot/ is misnamed; it does not say that there is one
root, but only says that an object is a root iff it has no parent.
The fact that there is only one root is captured by the
signature-related axioms above.
#+begin_src fopc
(∀x)(Object(x) ⇒ (Root(x) ⇔ ¬(∃y)(p(x, y)))
#+end_src

The fact /SingleParent/ is much as before but with the inverse
relation: For any objects /x/, /y/, and /z/, if /y/ is a parent of /x/
and /z/ is a parent of /x/, then /y/ = /z/.
#+begin_src fopc
(∀ x, y, z)((Object(x) ∧ Object(y) ∧ Object(z))
  ⇒ (p(x, y) ∧ p(x, z)
      ⇒
      (y = z)))
#+end_src

The fact /p\under{}acyclic/ requires the same machinery as was
needed above for /b\under{}acyclic/:
- a definition of the transitive closure of /p/, which we'll
  call /TCP/;
- a definition of the binary /iden/ relation; and
- a definition of the intersection of /pcb/ and /iden/.

TCP is the transitive closure of p.
#+begin_src fopc
(∀ x, y)(TCP(x, y) 
          ⇔ 
          (p(x,y) ∨ (∃z)(p(x,z) ∧ TCP(z,y))))
#+end_src

/iden/ is the identity relation.
#+begin_src fopc
(∀ x, y)(iden(x, y) ⇔ x = y)
#+end_src

As a set, /TCP\under{}and\under{}iden/ is the intersection of sets /TCP/ and /iden/.
In the predicate-based translation we are using, /TCP\under{}and\under{}iden/ is the
logical conjuntion of predicates /TCP/ and /iden/.
#+begin_src fopc
(∀ x, y)(TCP_inter_iden(x, y) 
          ⇔
          (TCP(x, y) ∧ iden(x, y)))
#+end_src

The set /TCP\under{}and\under{}iden/ is empty (or equivalently:  the
predicate /TCP\under{}and\under{}iden/ is true of no (x, y) pairs).
#+begin_src fopc
¬(∃ x, y)(TCP_and_iden(x, y))
#+end_src

The nameless fact ~C in p.B and D in p.B~ again constrains the set of
possible trees (but differently from the nameless fact of the earlier
model).  Because we know that each of the signatures /B/, /C/, and /D/
has cardinality one, it is tempting to translate this sentence as a
sentence about individuals:
#+begin_src fopc
(p(b, c) ∧ p(b, d)
#+end_src

But in general, every Alloy expression denotes a set, not an
individual; the closest Alloy comes to referring to individuals are
references to singleton sets.  So the correct translation is a
little wordier:
#+begin_src fopc
(∀x)(C(x) ⇒ (∃y)(B(y) ∧ p(x, y)))
∧ (∀x)(D(x) ⇒ (∃y)(B(y) ∧ p(x, y)))
#+end_src

** The modification and a new conjecture

At this point, van Eijck asks whether the fact /SingleParent/ in its
new form is perhaps redundant, entailed already by the declaration
~lone p: Object~.  So he removes the fact and replaces it with a
conjecture.

This conjecture seems worth checking, so we'll translate the third
model into TPTP notation.

** A TPTP rendering in FOF

In the FOF (first-order formula) language of the TPTP project
(thousands of problems for theorem provers), the modified model
using a parent relation can, I think, be represented as follows:

#+begin_src tptp :tangle ../examples/tree.jve2.axioms.p
% Everything is an Object or automatically supplied by Alloy.
% Nothing is both.
fof(top_signatures_1, axiom,
    ![X]: (object(X) | auto(X))).
fof(top_signatures_disjoint, axiom, 
    ~(?[X]: (object(X) & auto(X)))).

% Subsignatures Root, A, B, C, D have one instance each.
fof(sig_root_extends_object, axiom, 
    ![X]: (root(X) => object(X))).
fof(sig_root_min1, axiom, ?[X]: (root(X))).
fof(sig_root_max1, axiom, 
    ![X]: (root(X) => ![Y]: (root(Y) => X = Y))).

fof(sig_a_extends_object, axiom,
    ![X]: (a(X) => object(X))).
fof(sig_a_min1, axiom, ?[X]: (a(X))).
fof(sig_a_max1, axiom,
    ![X]: (a(X) => ![Y]: (a(Y) => X = Y))).

fof(sig_b_extends_object, axiom,
    ![X]: (b(X) => object(X))).
fof(sig_b_min1, axiom, ?[X]: (b(X))).
fof(sig_b_max1, axiom,
    ![X]: (b(X) => ![Y]: (b(Y) => X = Y))).

fof(sig_c_extends_object, axiom,
    ![X]: (c(X) => object(X))).
fof(sig_c_min1, axiom, ?[X]: (c(X))).
fof(sig_c_max1, axiom,
    ![X]: (c(X) => ![Y]: (c(Y) => X = Y))).

fof(sig_d_extends_object, axiom,
    ![X]: (d(X) => object(X))).
fof(sig_d_min1, axiom, ?[X]: (d(X))).
fof(sig_d_max1, axiom,
    ![X]: (d(X) => ![Y]: (d(Y) => X = Y))).

%  The subsignatures partition the set of objects.
fof(subsigs_of_object, axiom, 
    ![X]: (object(X) =>
            ((root(X) | a(X) | b(X) | c(X) | d(X))
             & ~(root(X) & a(X))
             & ~(root(X) & b(X))
             & ~(root(X) & c(X))
             & ~(root(X) & d(X))
             & ~(a(X) & b(X))
             & ~(a(X) & c(X))
             & ~(a(X) & d(X))
             & ~(b(X) & c(X))
             & ~(b(X) & d(X))
             & ~(c(X) & d(X))))).

% p takes objects as arguments
fof(p_types, axiom, 
    ![X, Y]: (p(X, Y) => (object(X) & object(Y)))).

% p is functional
fof(p_functional, axiom,
    ![X, Y]: (p(X, Y) => ![Z]: (p(X, Z) => (Z = Y)))).

% definition of root-ness
fof(oneroot, axiom, 
    ![X]: (object(X) => (root(X) <=> ~?[Y]: (p(X, Y))))).

% TCP is the transitive closure of p.
fof(tcp_def, definition,
    ![X, Y]: (tcp(X, Y) 
              <=> 
              (p(X,Y) | ?[Z]: (p(X,Z) & tcp(Z,Y))))).

% iden is the identity relation.
fof(iden_def, definition, 
    ![X, Y]: (iden(X, Y) <=> X = Y)).

% tcp_and_iden is the intersection of tcp and iden.
fof(tcp_and_iden_def, definition,
    ![X, Y]: (tcp_inter_iden(X, Y) 
              <=>
              (tcp(X, Y) & iden(X, Y)))).

% The set tcp_and_iden is empty.
fof(p_acyclic, axiom,
    ~?[X, Y]: (tcp_and_iden(X, Y))).

% B is the parent of both C and D
fof(fact_4, axiom,
    (![X]: (c(X) => ?[Y]: (b(Y) & p(X, Y)))
   & ![X]: (d(X) => ?[Y]: (b(Y) & p(X, Y))))).
#+end_src

The /SingleParent/ assertion can be represented
as a conjecture.
#+begin_src tptp :tangle ../examples/tree.jve2.conj-singleparent.p
% conjecture SingleParent
fof(singleparent, conjecture,
    ![X, Y, Z]: ((object(X) & object(Y) & object(Z))
      => ((p(X, Y) & p(X, Z))
          =>
          (Y = Z)))).
#+end_src

** Can /SingleParent/ conjecture be proved?

Both E and Vampire quickly prove the /SingleParent/ conjecture, but each
also reports:
#+begin_example
% SZS status Unsatisfiable 
#+end_example
(Interestingly, this appears in the ~--mode case_sat~ output from
Vampire, but not in ~--mode=casc~".)

Checking the axioms without the conjecture confirms that the axioms as
originally given are inconsistent.  (For the record: one stray
negation, possibly originating in the typo of tilde for exclamation
point, and two stray predicates applied to X when they should have
applied to Y.)

At this point, the original goals of this working paper appear
to have been achieved.  The paper illustrates:

- translation of simple Alloy models into FOPC and into the
  first-order form of the TPTP problem language;
- use of theorem provers to detect typos in the formulation of axioms
  (not one of the original goals, but helpful);
- use of theorem provers to check conjectures, whether false or true.

But a small extension may also be worth exploring: the translation of
the final model into the TFF0 ('monomorphic typed first-order form')
of TPTP.
  
** A TPTP rendering in TFF
In the TFF (typed first-order formula) language of the TPTP project,
the model could, I think, look like the following.

First, we declare the top-level signature /object/.
#+begin_src tptp :tangle ../examples/tree.jve2.axioms.tff.p
% Everything is an Object or automatically supplied by Alloy.
tff(sig_object, type, object: $tType).

% Nothing is both.
% (No statement necessary; follows automatically.)
#+end_src

Note that declaring /object/ as a type leads to an axiom
that at least one object exists:  TFF0 has no empty sorts.

Because the form of TFF we are using (TFF0?) has only disjoint
top-level types which (together with ~$i~) partition the set of
individuals, we cannot treat /Root/, /A/, /B/, /C/, and /D/
as types, and we cannot use those names in quantifiers.  So
the statements about these sub-signatures remain mostly similar
to those given above in the /fof/ language.

#+begin_src tptp :tangle ../examples/tree.jve2.axioms.tff.p
% Root, A, B, C, D are subsignatures of Object.
% I.e. the predicates Root, A, B, C, D apply to objects.
% And they have one instance each.
tff(sig_root_extends_object, type,
    root: ( object ) > $o).
tff(sig_root_min1, axiom,
    ?[X : object]: (root(X))).
tff(sig_root_max1, axiom, 
    ![X : object]: (root(X) => ![Y : object]: (root(Y) => X = Y))).

tff(sig_a_extends_object, type,
    a: (object) > $o).
tff(sig_a_min1, axiom,
    ?[X : object]: (a(X))).
tff(sig_a_max1, axiom,
    ![X : object]: (a(X) => ![Y : object]: (a(Y) => X = Y))).

tff(sig_b_extends_object, type,
    b: (object) > $o).
tff(sig_b_min1, axiom,
    ?[X : object]: (b(X))).
tff(sig_b_max1, axiom,
    ![X : object]: (b(X) => ![Y : object]: (b(Y) => X = Y))).

tff(sig_c_extends_object, type,
    c: (object) > $o).
tff(sig_c_min1, axiom,
    ?[X : object]: (c(X))).
tff(sig_c_max1, axiom,
    ![X : object]: (c(X) => ![Y : object]: (c(Y) => X = Y))).

tff(sig_d_extends_object, type,
    d: (object) > $o).
tff(sig_d_min1, axiom,
    ?[X : object]: (d(X))).
tff(sig_d_max1, axiom,
    ![X : object]: (d(X) => ![Y : object]: (d(Y) => X = Y))).
#+end_src

It is not clear a priori whether the typed quantifiers in the formulas
just given are helpful, or if they are wholly redundant given the type
declarations.  (A posteriori, it appears that Vampire, at least, is
unhappy if they are not present: a quantifier without a sort is taken
to declare the variable as being of type ~$i~, which Vampire takes to
be disjoint from ~object~.

#+begin_src tptp :tangle ../examples/tree.jve2.axioms.tff.p

%  The subsignatures partition the set of objects.
tff(subsigs_of_object, axiom, 
    ![X : object]:
            (((root(X) | a(X) | b(X) | c(X) | d(X))
             & ~(root(X) & a(X))
             & ~(root(X) & b(X))
             & ~(root(X) & c(X))
             & ~(root(X) & d(X))
             & ~(a(X) & b(X))
             & ~(a(X) & c(X))
             & ~(a(X) & d(X))
             & ~(b(X) & c(X))
             & ~(b(X) & d(X))
             & ~(c(X) & d(X))))).

% p takes objects as arguments
tff(p_types, type, p: (object * object) > $o).

% p is functional
tff(p_functional, axiom,
    ![X : object, Y : object]:
    (p(X, Y) => ![Z : object]: (p(X, Z) => (Z = Y)))).

% definition of root-ness
tff(oneroot, axiom, 
    ![X : object]: (root(X) <=> ~?[Y : object]: (p(X, Y)))).

% TCP is the transitive closure of p.
tff(tcp_type, type, tcp : (object * object) > $o).
tff(tcp_def, definition,
    ![X : object, Y : object]:
        (tcp(X, Y) 
        <=> 
        (p(X,Y) | ?[Z : object]: (p(X,Z) & tcp(Z,Y))))).

% iden is the identity relation on objects.
% user-defined predicates cannot be polymorphic.
tff(iden_type, type, iden : (object * object) > $o).
tff(iden_def, definition, 
    ![X : object, Y : object]: (iden(X, Y) <=> X = Y)).

% tcp_and_iden is the intersection of tcp and iden.
tff(tcp_and_iden_type, type,
    tcp_and_iden : (object * object) > $o).
tff(tcp_and_iden_def, definition,
    ![X : object, Y : object]:
        (tcp_and_iden(X, Y) 
        <=>
        (tcp(X, Y) & iden(X, Y)))).

% The set tcp_and_iden is empty.
tff(p_acyclic, axiom,
    ~?[X : object, Y : object]: (tcp_and_iden(X, Y))).

% B is the parent of both C and D
tff(fact_4, axiom,
    (![X : object]: (c(X) => ?[Y : object]: (b(X) & p(X, Y)))
   & ![X : object]: (d(X) => ?[Y : object]: (b(X) & p(X, Y))))).
#+end_src

The /SingleParent/ assertion can be represented
as a conjecture.
#+begin_src tptp :tangle ../examples/tree.jve2.conj-singleparent.tff.p
% conjecture SingleParent
tff(singleparent, conjecture,
    ![X : object, Y : object, Z : object]:
        ((p(X, Y) & p(X, Z))
         =>
         (Y = Z))).
#+end_src

Attempting to prove this conjecture turned up (again) a number of
issues in the hand translation, which seem to indicate that the
translations from Alloy into FOPC and TPTP really should be automated.
Concretely, Vampire was unhappy with the input until all predicates
had been properly declared specifying that their arguments were of
type /object/ and all quantifiers were also typed with /object/.

Once the tff version was well-typed in Vampire's estimation, Vampire
proved the assertion both in /casc/ and in /case\under()sat/ modes.  E also
proved it, in both ~--auto~ and ~--auto-schedule~.

* Tentative conclusions

The work described here seems to provide a rudimentary demonstration
that work in Alloy can be usefully supplemented with work using
automatic theorem provers, when it is desired to prove theorems about
the models described in Alloy.

By design, Alloy does not attempt to prove theorems; given a
description of some constraints, the Alloy Analyzer limits itself to
finding finite models which satisfy the constraints, or to finding
counter-examples which satisfy the base constraints but violate an
assertion.  Testing an asertion in Alloy can show that there are no
counter-examples smaller than the specified scope; proving the
assertion in a theorem prover can show that there can be no
counter-examples.

The simple examples exhibited above show some pitfalls that can arise:

- Syntactic errors are possible in any formal description of a model.
  It may safely be said that few tools provide uniformly helpful
  diagnostic messages for syntax errors, and the tools used here are
  not exceptions to that general rule.  It seems likely that an
  automatic translation can produce output that is more reliably
  grammatical in the target language.

- The Alloy language is not a perfect match for the language accepted
  by first-order theorem provers.

    + Alloy expressions denote sets of tuples; neither tuples nor sets
      are naturally present in the core of first-order logic.

      The translations offered here attempt to render the Alloy models
      in a first-order formulation without any reference to sets or to
      the axioms of set theory.  It is a pragmatic question whether it
      is better to use such a set-less language, to translate the
      Alloy models into a first-order logic augmented with the axioms
      of set theory, or to give up on any target language that lacks
      sets; the answer to that question is still open.

      The example of the /b\under{}acyclic/ and /p\under{}acyclic/
      constraints suggest that arbitrarily complex Alloy expressions
      can be translated reliably into FOPC without sets by reifying
      each expression and subexpression into a characteristic
      predicate which is true for all and only the memmbers of the set
      denoted by the expression. This will create a perhaps tedious
      need to define names for things left anonymous in the Alloy
      models, but in an automated translation that should be
      tractable.
      
    + The signatures of Alloy can be rendered in colloquial FOPC
      with the kind of informal typing the authors have often used
      in paper.

      In TPTP's FOF sublanguage they can be rendered as predicates, at
      the cost of a certain amount of wordiness.  There are some
      suggestions in the literature that such predicates may sometimes
      cause problems for automatic provers (either because of the
      sheer wordiness of the translations or because the additional
      rules complicate the search space).
      
      In the TFF sublanguage, top-level Alloy signatures can be
      rendered as user-defined sorts; subsignatures, however, cannot
      (at least, not in the version of TFF documented in Sutcliffe et
      al. 2012), so type predicates for subsignatures and formulas
      expressing constraints like pairwise disjointness are still
      necessary.

  Some complications are not illustrated here, but must be addressed
  at some point:

    + Alloy provides at least small subsets of the integers, with
      built-in knowledge of things like set cardinality.
      
      TFF0 does provide integers and basic arithmetic, at least in the
      sense of allowing them to be referred to.  Some TFF0 processors
      can do basic arithmetic.

      Fortunately, our models do not make heavy use of integers.

    + Alloy provides sequences, modeled as functions from a prefix
      of the natural numbers to elements in a domain.

      Sequences are not pre-defined as part of FOF or TFF (or indeed
      any TPTP language), as far as we have seen.

      It will be necessary either to formulate a set of rules about
      sequences (borrowed, perhaps, from the relevant Alloy utility
      modules) or to shift to a different model of sequences.  The
      paper by Sutcliffe et al (2012) introducing TFF gives an example
      of defining sequences in roughly the same way that Lisp defines
      lists, defining a constant for the empty list and a /cons/
      function which takes an item and prepends it to a list.  (It
      will, I hope, not be necessary to replicate Lisp's improper
      lists and so on.)

      

* References

- Geoff Sutcliffe, Stephan Schulz, Koen Claessen, and Peter
  Baumgartner, "The TPTP Typed First-order Form with Arithmetic",
  /Proceedings of the 18th LPAR/, Merida, 2012, ed. Dines Bjørner and
  Andrei Voronkov (= LNAI 7180) (Springer, 2012), pp. 406-419,

  On the Web at various places including
  http://wwwlehre.dhbw-stuttgart.de/~sschulz/PAPERS/SSCB-LPAR-2012.pdf



# (modify-syntax-entry ?< "_")
# (modify-syntax-entry ?> "_")

