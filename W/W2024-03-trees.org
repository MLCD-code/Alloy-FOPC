#+title: Experiments with tree models in Alloy
#+author: CMSMcQ 
#+date: 28 March - 12 April 2024, resumed 2 May 2024

This document describes a translation of some simple Alloy models of
trees into first-order logic and some experiments with translating
them into first-order logic.  

The models are borrowed from teaching materials for a course on
software testing published on the web by Jan van Eijck of the
University of Amsterdam, specifically from the lecture notes on
[[https://staff.fnwi.uva.nl/d.j.n.vaneijck2/courses/10/pdfs/Week4.pdf][Specifications and assertions]].

The document was written bit by bit and thus has some characteristics
of a work log.  In particular, the bits at the beginning don't know
for sure where the last bits are going, and there are digressions and
notes about things that may or may not be important but which I don't
want to forget.  The reader is requested to be patient.

* The first Alloy model

** The Alloy

The first model appears on slide 3:
#+begin_src alloy
/* Tree Specification in Alloy */
module myexamples/tree

sig Object { b: set Object }
one sig Root, A, B, C, D extends Object {}

fact OneRoot { all x: Object | x = Root <=> no b.x }
fact b_acyclic { no ^b & iden }

fact { C in B.b and D in C.b }

pred show () {}
run show for 5
#+end_src

A (slightly rough) English paraphrase might be as follows.
From the signature declarations, we have:
  - Objects Root, A, B, C, and D exist; there are no other objects.
  - Each object has a field /b/ whose value is a set of objects.
    (Informally: for any object /X/, /X.b/ is the set of /X/'s
    children.)  Note that /b/ can also be described simply as a binary
    relation /b/ on objects.

From the fact /OneRoot/ we have:
  - An object is the Root object if and only if it is not a member of
    the value of /b/ for any object.

From the fact /b\under{}acyclic/ we have:
  - The intersection of the transitive closure of /b/ (viewed as a
    binary relation) and the identity relation is empty (i.e. they are
    disjoint).  This means, in effect, that no object /X/ can be
    reached by starting at /X/ and traversing the /b/ relation any
    positive number of times.

From the unnamed third fact we have:
  - Object C is a member of the /b/ field of B (i.e. C is one of B's
    children), and D is a child of C.

The predicate /show/ imposes no constraints, so it hold for any
instance of the model; the /run/ command, when executed, asks Alloy to
find an instance of the predicate /show/ in a universe with at most 5
objects of any signature.

** The FOPC translation

*** The signature declarations

In our usual first-order calculus notation, we can perhaps render this
model as follows.

There is only one top-level signature, so everything is either an
object or a member of an automatically supplied signature (like Int),
and nothing is both.
#+begin_src fopc
(∀x)(Object(x) aut AUTO(x))
#+end_src

The five signatures Root, A, B, C, D are all sub-signatures of Object,
and each is declared with a cardinality of one.  That means first that
there is at least one individual in each of these signatures, and then
also that any individual which is a member of these signatures is an
object, and if /x/ and /y/ are members of one of these signatures,
then /x/ and /y/ are the same individual.

#+begin_src fopc
(∃x)(Root(x))
(∀x: Root)(Object(x))
(∀x: Root)(∀y: Root)(x = y)
(∃x)(A(x))
(∀x: A)(Object(x))
(∀x: A)(∀y: A)(x = y)
(∃x)(B(x))
(∀x: B)(Object(x))
(∀x: B)(∀y: B)(x = y)
(∃x)(C(x))
(∀x: C)(Object(x))
(∀x: C)(∀y: C)(x = y)
(∃x)(D(x))
(∀x: D)(Object(x))
(∀x: D)(∀y: D)(x = y)
#+end_src

Furthermore, the sub-signatures partition the parent signature:
#+begin_src fopc
(∀x: Object)(Root(x) aut A(x) aut B(x) aut C(x) aut D(x))
#+end_src

Without typed declarations and without exclusive or, these become a
bit wordier.

#+begin_src fopc
(∀x)(Object(x) ∨ AUTO(x))
¬(∃x)(Object(x) ∧ AUTO(x))
(∃x)(Root(x))
(∀x)(Root(x) ⇒ (Object(x) ∧ (∀y)(Root(y) ⇒ x = y)))
(∃x)(A(x))
(∀x)(A(x) ⇒ (Object(x) ∧ (∀y)(A(y) ⇒ x = y)))
(∃x)(B(x))
(∀x)(B(x) ⇒ (Object(x) ∧ (∀y)(B(y) ⇒ x = y)))
(∃x)(C(x))
(∀x)(C(x) ⇒ (Object(x) ∧ (∀y)(C(y) ⇒ x = y)))
(∃x)(D(x))
(∀x)(D(x) ⇒ (Object(x) ∧ (∀y)(D(y) ⇒ x = y)))
(∀x)(Object(x) ⇒
        ((Root(x) ∨ A(x) ∨ B(x) ∨ C(x) ∨ D(x))
         ∧ ¬(Root(x) ∧ A(x))
         ∧ ¬(Root(x) ∧ B(x))
         ∧ ¬(Root(x) ∧ C(x))
         ∧ ¬(Root(x) ∧ D(x))
         ∧ ¬(A(x) ∧ B(x))
         ∧ ¬(A(x) ∧ C(x))
         ∧ ¬(A(x) ∧ D(x))
         ∧ ¬(B(x) ∧ C(x))
         ∧ ¬(B(x) ∧ D(x))
         ∧ ¬(C(x) ∧ D(x)))
#+end_src

*** The fact /OneRoot/

/OneRoot/ says that for all objects, the object is the Root if and
only if no object has it as a child.

#+begin_src fopc
(∀x: Object)(Root(x) ⇔ ¬(∃y)(b(y, x)))
#+end_src

*** The fact /b\under{}acyclic/

The fact /b\under{}acyclic/ is, closely paraphrased, a statement
about the cardinality of a set.

We cannot define the transitive closure operator
"~^~" in a first-order system, so we will need to
define the transitive closure of /b/ as a named
relation, in the usual recursive way:
#+begin_src fopc
(∀ x, y)(tcb(x, y) 
          ⇔ 
          (b(x,y) ∨ (∃z)(b(x,z) ∧ tcb(z,y))))
#+end_src

We may need to define /iden/ as well:
#+begin_src fopc
(∀ x, y)(iden(x, y) ⇔ x = y)
#+end_src

A direct translation of the fact might then be:
#+begin_src fopc
¬(∃ x, y)(tcb(x, y) ∧ iden(x, y))
#+end_src

For complex expressions denoting relations, it might be
better to reify and name the relations denoted by the
subexpressions.  We have already done that for "~^b~" and
"~iden~" here, so we are already part-way there.  A blind
reification of each level in the structure would replace
the direct translation with another reification and then
a simpler statement of the fact:
#+begin_src fopc
(∀x, y)(tcb_inter_iden(x, y) 
          ⇔
          (tcb(x, y) ∧ iden(x, y)))
¬(∃ x, y)(tcp_inter_iden(x, y))
#+end_src
*** The nameless fact
The third fact specifies that B is the parent of C and C the parent of
D.  Or, more precisely, that the single atom of signature B is the
parent of the single atom of signature C, and so on.  Or, given that
they are unique, more simply it says that for any atoms x, y, and z
of signature B, C, and D respectively, the parent/child relation /b/
holds for the pairs (x, y) and (y, z).
#+begin_src fopc
(∀x : B)(∀y : C)(∀z : D)(b(x, y) ∧ b(y, z))
#+end_src


* Checking an example

** The example 
Given the model above, Alloy can generate examples, including one we
can display as a nested list:

- Root
  + B
    - C
      + D
  + A

Or, as an image:

[[./images//jve-tree.dot.png]]

Can we prove in first-order logic what Alloy has told us, namely
that this instance is consistent with the constraints of the model?

** Expressing the example in FOPC

I'm not completely certain of the right way to express this instance
as a set of formulas in our target language, but a first cut would be:

#+begin_src fopc
b(Root, B)
b(Root, A)
b(B, C)
b(C, D)
#+end_src

On further consideration, however, I see that this assumes that the
signature names are constants designating individuals, which is wrong
in several ways.  A second attempt to describe the example says that
in the state of affairs reflected in it, there are five individuals,
one for each declared signature, and they have the relations shown.
Since the uniqueness of each signature has already been established
(or should have been), we don't need to specify that there are exactly
five such individuals but can focus on their signatures and relations.

We can conceive of this as a predicate that holds for five
individuals, which might be declared in Alloy this way:
#+begin_src alloy
pred example[x: Root, y: A, z: B, w: C, v: D] {
 y in b[x]
 z in b[x]
 w in b[z]
 v in b[w]
}
#+end_src
Mnemonic names (/a/ for the member of signature /A/, for example)
would be nicer, but /b/ as the name both for the relation /b/ and the
atom /b/ of signature /B/ was a step too far for me.  (I believe it's
also a step too far for the TPTP theorem provers we are using.)

We could also conceive of our description of the example as a
predicate that takes no arguments but is just true or not true.
#+begin_src fopc
pred example {
 some x: Root, y: A, z: B, w: C, v: D {
   y in b[x]
   z in b[x]
   w in b[z]
   v in b[w]
 }
}
#+end_src
We can translate either of these into FOL; let's pick the second.
#+begin_src fopc
example ⇔ (
  (∃ x, y, z, w, v)
  ( (Root(x) ∧ A(y) ∧ B(z) ∧ C(w) ∧ D(v)
    ∧ b(x, y)
    ∧ b(x, z)
    ∧ b(z, w)
    ∧ b(w, v)
)
#+end_src

** How to check that the example is allowed?

[Note: the discussion below exhibits a certain amount of confusion
about how to check examples.  That task has since come to seem
simpler, but the confused discussion below is retained, since it
illustrates that our current understanding did not always seem
obvious.]

If there can be no instance that satisfies the statements just given
(call their conjunction /E/), then both of the following formulations
of the state of affairs will be true:

- The constraints of the model entail ¬/E/.
- The conjunction of /E/ with the constraints of the model will be
  inconsistent.

Since entailment of /E/ by /M/ is established, in many systems, by
showing that the conjunction /M/ ∧ ¬/E/ is inconsistent, these two
statements boil down to the same thing.

Let's try it.

It may be worth pointing out that this particular example poses no
great difficulty -- it was produced by Alloy, which is very good at
producing instances compatible with the constraints of a model, and
the example is simple enough that one can easily see that it's
consistent with the model.  Moreover, it's small enough that one could
in a pinch assume five individuals and generate a complete set of
closed clauses and a complete set of literals, and show that the set
of literals has no contradictions.  The point of trying to use a
theorem prover to show that the example is consistent with the
constraints is to gain a tool for use on manually constructed examples.

** A TPTP translation of the model and example

In TPTP notation, first-order formulas are labeled as such and 
given names and roles.  So the overall structure of each formula
will match the following grammar (I'm ignoring whitespace for
simplicity):
#+begin_src ixml
tptp-formula: "fof(", name, ",", role, ",", formula, ")".
name: [L], [L; Nd; "_"]*.
role: "axiom"      { start here }
    ; axiom-like
    ; "conjecture" { formula to be proved }
    ; other-roles
    .
axiom-like: "hypothesis" { assumed true, used like axioms }
          ; "definition" { universally quantified equations 
                           or equivalences with atomic LHS,
                           intended to define symbols }
          ; "assumption" { like axiom but "must be discharged
                           before a derivation is complete" }
          ; "lemma"      { has been proved, must follow from axioms }
          ; "theorem"    { has been proved, must follow from axioms }
                         { problem with non-redundant lemma or theorem
                           is ill-formed }
         
other-roles: { probably irrelevant for us? }
             "corollary" | "negated_conjecture" | "plain" 
           | "type" | "interpretation" | "fi_domain" | "fi_functors" 
           | "fi_predicates" | "unknown".
formula: ...
#+end_src

The FOPC rules given above can, I think, be rendered into TPTP as
follows.  Some notes:
- Since TPTP uses the Prolog convention of spelling variables with
  initial uppercase letters and requiring functors to begin with
  lowercase letters (or be quoted), I've lowercased all the signature
  names.
- The theorem prover E objects if the same predicate symbol is used
  with different arities, so this TPTP translation writes "~pc(X, Y)~"
  where the logical rules given above write "b(x, y)".

#+begin_src tptp :tangle ../examples/tree.jve1.axioms.p
/* Signature Object */
fof(sigo1, axiom,
   ( ! [X] : (object(X) | auto(X)))).
fof(sigo2, axiom,
   (~ ? [X] : (object(X) & auto(X)))).

/* Signatures root, a, b, c, d */
fof(sigr1, axiom, (?[X] : root(X))).
fof(sigr2, axiom, 
    ( ! [X] : (root(X) => (object(X) & ( ! [Y] : (root(Y) => (X = Y)))))) ).
fof(siga1, axiom, (?[X] : a(X))).
fof(siga2, axiom, 
    ( ! [X] : (a(X) => (object(X) & ( ! [Y] : (a(Y) => (X = Y)))))) ).
fof(sigb1, axiom, (?[X] : b(X))).
fof(sigb2, axiom, 
    ( ! [X] : (b(X) => (object(X) & ( ! [Y] : (b(Y) => (X = Y)))))) ).
fof(sigc1, axiom, (?[X] : c(X))).
fof(sigc2, axiom, 
    ( ! [X] : (c(X) => (object(X) & ( ! [Y] : (c(Y) => (X = Y)))))) ).
fof(sigd1, axiom, (?[X] : d(X))).
fof(sigd2, axiom, 
    ( ! [X] : (d(X) => (object(X) & ( ! [Y] : (d(Y) => (X = Y)))))) ).

/* Root, A-D partition Object */
fof(sigosubs, axiom,
    ( ! [X] : ( object(X) =>
              ( (root(X) | a(X) | b(X) | c(X) | d(X))
                & ~(root(X) & a(X))
                & ~(root(X) & b(X))
                & ~(root(X) & c(X))
                & ~(root(X) & d(X))
                & ~(a(X) & b(X))
                & ~(a(X) & c(X))
                & ~(a(X) & d(X))
                & ~(b(X) & c(X))
                & ~(b(X) & d(X))
                & ~(c(X) & d(X)))))).

/* fact OneRoot */
fof(oneroot, axiom,
   (![X]: (root(X) <=> (~?[Y]: (pc(Y,X)))))).

/* definition of tcb (^b) */
fof(def_tcb, axiom,
   (![X, Y]: (tcb(X, Y) <=> ((pc(X, Y))|(?[Z]:(pc(X, Z) & tcb(Z, Y))))))).

/* fact b_acyclic */
fof(b_acyclic, axiom,
  (~?[X, Y]:(tcb(X,Y) & (X = Y)))).

/* fact 3 (nameless) */
fof(fact3, axiom,
   (![X,Y,Z] : ((b(X) & c(Y) & d(Z)) => (pc(X, Y) & pc(Y, Z))))).
#+end_src

The example translates into TPTP syntax as follows:
#+begin_src tptp :tangle ../examples/tree.jve1.ex-def.p
/* Definition of example */
fof(example1, definition,
  (example <=> ?[X, Y, Z, W, V] :
               (root(X) & a(Y) & b(Z) & c(W) & d(V)
                & pc(X,Y) & pc(X,Z) & pc(Z,W) & pc(W,V)))).
#+end_src

** Testing

*** Initial attempt to test the example

To check whether the example is possible, we can ask the prover to prove
that it is impossible.
#+begin_src tptp :tangle ../examples/tree.jve1.ex-neg-conj.p
fof(ex1nogo, conjecture, ~example).
#+end_src

If we place the TPTP description of the model, with this conjecture,
in a file named /tree.jve1.p/ and pass it to the theorem prover /E/,
with "~eprover --auto --output-file=tree.jve1.e.out tree.jve1.p~",
then (as expected) /E/ fails to prove the conjecture.

For the record: the version of /E/ I'm running appears to be 2.6
"Floral Guranse".

(One detail was a little puzzling.  I thought that the default value
for the /--cpu-limit/ option was 300 (seconds), but /E/ ran for half
an hour or so and produced 35 MB of output before I stopped it.
Closer examination of the output of "~eprover -h~" shows my
misunderstanding.  What it says is "The option without the optional
argument is equivalent to ~--cpu-limit=300~."  That is, if you specify
"~--cpu-limit~", you get 300 seconds.)

Unfortunately, any automated theorem prover will sometimes fail to
prove a true conjecture, so this is not completely satisfactory.  What
we would like is a clear indication that the example is consistent
with the assumptions.  In a tableau proof, we can (at least in some
cases) produce a proof tree which is not closed but is complete, and
we can construct a counterexample to the conjecture by reading off the
values for various literals by running down any open branch.  Can we
do that, or something analogous, with /E/ or with any other theorem
prover?

*** Diagnosing the problem

After a digression to a simpler example, I tried this again, with a
soft CPU limit of 30 seconds.  It timed out.

Next, I tried a primitive binary chop.
1. Tried the first half of the model (down to axiom /sigd2/
   inclusive).  It showed the (truncated) model satisfiable, in
   about 15 msec.
2. Added /sigosubs/ and /oneroot/; that is 42 lines of 63.
   Satisfiable, 23 msec.
3. Added /def\under{}tcb/ and /b\under{}acyclic/.  I wonder if the
   recursion here is part of the problem.  It is; /E/ times out.
4. Leave the definition of tcb in place, but comment out the
   translation of /b\under{}acyclic/.  Still times out.
5. Comment out the two axioms added in step 3 of this diagnostic
   process, restore all the others: /fact3/, /example/.  Times out.
6. Comment out definition of /example/.  Shown satisfiable in 23 msec.
7. Try alternate definition of example (as predicate of arity 5).
   Satisfiable, 23 msec.

Retrying the two definitions of the example, one making /example/ a
proposition true iff there are five individuals with a given
configuration and the other making it a predicate over five arguments,
I find that I am unable to replicate the timing shown for step 5.
Either way it takes a little over 20 milliseconds.

*** A simpler way

As the reader may know, some automatic theorem provers work by
assuming the negation of the conjecture and deriving a contradioction
-- a sort of mechanized /reductio ad absurdum/.  In such a theorem
prover, it should be straightforward to see whether a set of axioms is
consistent, without trying to prove a theorem.

And behold! some such provers -- at least E and Vampire -- are
perfectly happy to do this.

So a simpler and more reliable way to show that the example is
consistent with the axioms is to feed the prover input containing:
- the axioms shown above
- the definition of a predicate representing the example 
- the example-predicate as a hypothesis as shown below.
  
#+begin_src tptp :tangle ../examples/tree.jve1.ex-hyp.p
fof(ex1nogo, hypothesis, example).
#+end_src

If there is no conjecture in the input, both E and Vampire will take
their task to be checking the axioms and hypotheses for
satisfiability.  (The author of E is explicit that finding models for
sets of axioms is not E's strength, and other provers may do better.)

The simplest way to combine the axioms with different conjectures and
hypotheses will be to write the axioms to one file, the conjectures
and hypotheses to different files, and then combine them before
calling the provers.  Both E and Vampire accept a problem description
on the standard input, so the shell command can look like this:

#+begin_example
cat tree.jve1.axioms.p \
    tree.jve1.ex-def.p \
    tree.jve1.ex-hyp.p \
  | eprover --auto \
            --soft-cpu-limit=120 \
            --output-level=0
#+end_example

First, the three files containing the axioms, the definition of the
predicate /example/, and the hypothesis that /example/ holds are
concatenated using /cat/ and fed into the standard input port of E,
invoked with a soft CPU limit of 120 seconds, in 'automatic' mode
(which is what the documentation recommends as "the easiest way to
get good performance".

When we invoke E as shown, it times out without producing a result.
Using the ~--auto-schedule~ option causes E to try an array of
strategies, but none succeed here.

Vampire can be invoked thus:
#+begin_example
cat tree.jve1.axioms.p \
    tree.jve1.ex-def.p \
    tree.jve1.ex-hyp.p \
  | vampire --mode casc_sat \
            -t 30
#+end_example

Here, we have specified a time limit of 30 seconds, and a ~casc_sat~
mode, which implements a strategy used in CASC competitions for
problems whose specifications are expected to be satisfiable.

Invoked with mode ~casc_sat~, Vampire tries a portfolio of approaches,
one of which succeeds and produces the message "Finite Model Found!"
The logging output is a little terse, but seems to indicate that the
successful approach involved choosing "~fmb~" (for 'finite model building
for satisfiable problems') as the 'saturation algorithm'.  So a more
direct way to get a result here is to invoke Vampire with the option
"~-sa fmb~".

[Note:  using the fmb option appears to cause some sort of problem.
Immediately after the "Finite Model Found!" message, I get the messages
#+begin_example
% SZS status Satisfiable for 
164958 Aborted by signal SIGSEGV on 
#+end_example
followed by normal-looking output from Vampire.

* Checking an assertion

Having presented the example above, van Eijck remarks:
#+begin_quote
- This looks OK, but is it?
- Hmm, maybe not. We forgot to say that every other object but
  the root has exactly one B-predecessor.
- Maybe it follows from our specification. Let us check.
#+end_quote

He then suggests an assertion that can be checked:
#+begin_src alloy
assert SingleParent
  { all x,y,z: Object | z in x.b and z in y.b => x=y }
check SingleParent for 5
#+end_src

Alloy checks the assertion by finding a counter-example within
the scope specified; in principle, a prover cand check
the assertion more broadly (although it's clear that in practice
at least some disproofs are going to take the form of finding
a counter-example).

#+begin_src tptp :tangle ../examples/tree.jve1.conj-single-parent.p
fof(single_parent, conjecture,
  ![X, Y, Z] : (object(X) & object(Y) & object(Z) =>)
).
#+end_src

* A second Alloy model

** The Alloy

The second model appears on slide 7:
#+begin_src alloy
/* Corrected specification */
module myexamples/tree

sig Object { b: set Object }
one sig Root, A, B, C, D extends Object {}
fact OneRoot { all x: Object | x = Root <=> no b.x }
fact SingleParent
  { all x,y,z: Object | z in x.b and z in y.b => x=y }
fact b_acyclic { no ^b & iden }

fact { C in B.b and D in C.b }

pred show () {}
run show for 5
#+end_src

The English paraphrase is the same as before, with one addition for
the fact /SingleParent/:

- No object is in the value of /b/ for two distinct parent objects.

(modify-syntax-entry ?< "_")
(modify-syntax-entry ?> "_")
